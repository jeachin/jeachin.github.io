<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>小C的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="小C的博客">
<meta property="og:url" content="https://mrxccc.github.io/page/5/index.html">
<meta property="og:site_name" content="小C的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="mrxccc">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="小C的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小C的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mrxccc.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-同步容器与JUC并发容器的对比与介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/933755ce.html" class="article-date">
  <time class="dt-published" datetime="2019-08-10T01:23:20.000Z" itemprop="datePublished">2019-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/933755ce.html">同步容器与JUC并发容器的对比与介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-容器集简单介绍"><a href="#1-容器集简单介绍" class="headerlink" title="1 容器集简单介绍"></a>1 容器集简单介绍</h1><p>java.util包下面的容器集主要有两种，一种是Collection接口下面的List和Set，一种是Map,<br>大致结构如下： </p>
<ul>
<li><p>Collection  </p>
<ul>
<li>List  <ul>
<li>LinkedList</li>
<li>ArrayList</li>
<li>Vector<ul>
<li>Stack</li>
</ul>
</li>
</ul>
</li>
<li>Set  <ul>
<li>HashSet</li>
<li>TreeSet</li>
<li>LinkedSet</li>
</ul>
</li>
</ul>
</li>
<li><p>Map  </p>
<ul>
<li>Hashtable</li>
<li>HashMap</li>
<li>WeakHashMap</li>
</ul>
</li>
</ul>
<h1 id="2-同步容器"><a href="#2-同步容器" class="headerlink" title="2 同步容器"></a>2 同步容器</h1><p>同步容器也叫线程安全容器，是通过<strong>syncrhoized关键字</strong>对线程不安全的操作进行加锁来保证线程安全的<br>其中同步容器主要包括:<br>1.Vector、Stack、HashTable<br>2.Collections 工具类中提供的同步集合类<br>Collections类是一个工具类，相当于Arrays类对于Array的支持，Collections类中提供了大量对集合或者容器进行排序、查找的方法。它还提供了几个静态方法来创建同步容器类：</p>
<h1 id="3-并发容器"><a href="#3-并发容器" class="headerlink" title="3 并发容器"></a>3 并发容器</h1><p>java.util.concurrent提供了多种线程安全容器，大多数是使用系统底层技术实现的线程安全，也叫并发容器，类似native。Java8中使用CAS。</p>
<h1 id="4-案例讲解"><a href="#4-案例讲解" class="headerlink" title="4 案例讲解"></a>4 案例讲解</h1><p>这里主要介绍一些常见的同步容器和并发容器，通过案例输出结果对比进行介绍<br>我大致分为了三类Map&#x2F;Set,List,Queue来进行讲解,但一个Map&#x2F;Set，只介绍了Map,因为在java的设计中，Set就是Map，说白了就是只有Key没有Value的Map，好了，现在开始进入正题</p>
<h2 id="4-1-Map-Set"><a href="#4-1-Map-Set" class="headerlink" title="4.1 Map&#x2F;Set"></a>4.1 Map&#x2F;Set</h2><p>代码中new了三个Map,HashTable，ConcurrentHashMap，ConcurrentSkipListMap比较每个map的运行效率，起100个线程向map中存放10000条随机数，并通过门闩CountDownLatch控制运行状态，输出运行时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - ConcurrentMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_01_ConcurrentMap</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// final Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class="line">		<span class="comment">// final Map&lt;String, String&gt; map = new ConcurrentSkipListMap&lt;&gt;();</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		Thread[] array = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">		<span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(array.length);</span><br><span class="line">		</span><br><span class="line">		<span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">			array[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++)&#123;</span><br><span class="line">						map.put(<span class="string">&quot;key&quot;</span>+r.nextInt(<span class="number">100000000</span>), <span class="string">&quot;value&quot;</span>+r.nextInt(<span class="number">100000</span>));</span><br><span class="line">					&#125;</span><br><span class="line">					latch.countDown();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Thread t : array)&#123;</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			latch.await();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;执行时间为 ： &quot;</span> + (end-begin) + <span class="string">&quot;毫秒！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Hashtable结果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmNTQxZGQ1MDlkMDA"></p>
<p>ConcurrentHashMap结果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmNDU3MGMxZWFhODY"></p>
<p>ConcurrentSkipListMap结果:</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmNTg3ZmIyYjZiZmI"></p>
<p>ConcurrentHashMap的底层是哈希实现的同步Map(Set)<br>ConcurrentSkipListMap内部是SkipList（跳表）结构实现的非阻塞读&#x2F;写&#x2F;删除 的 Map，它的value是有序存储的, 而且其内部是由纵横链表组成，在JDK1.8中，ConcurrentHashMap的性能和存储空间要优于ConcurrentSkipListMap</p>
<p>为了让测试数据结果对比更加直观，我这里故意将生成的随机数调的比较大。这里需要注意一下，在测试的时候，如果机器性能比较好，可能结果会出现误差，因为System.currentTimeMillis()，这个方法调用了个native方法，获取的时间精度会依赖于操作系统的实现机制，具体为什么，可以看看这篇文章<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_6b8bd9d80101fe8t.html%E3%80%82%E4%BD%86%E6%88%91%E6%8C%89%E7%85%A7%E6%96%87%E6%A1%A3%E7%9A%84%E5%8A%9E%E6%B3%95%E5%B0%86System.currentTimeMillis()%E6%94%B9%E4%B8%BASystem.nanoTime()%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%BE%BE%E5%88%B0%E7%BA%B3%E7%A7%92%E7%BA%A7%E5%88%AB%E5%90%A7%E3%80%82">http://blog.sina.com.cn/s/blog_6b8bd9d80101fe8t.html。但我按照文档的办法将System.currentTimeMillis()改为System.nanoTime()，发现并没有解决这个问题，可能是因为并没有达到纳秒级别吧。</a></p>
<h2 id="4-2-List"><a href="#4-2-List" class="headerlink" title="4.2 List"></a>4.2 List</h2><p>下面代码与4.1的代码类似，也是new了三个List,ArrayList，Vector，CopyOnWriteArrayList，起100个线程向map中存放1000条随机数，并通过门闩CountDownLatch控制运行状态，输出运行时间和最后list的的长度。<strong>由于ArrayList是线程不安全，在多线程执行的时候，需要try{}catch{},否则会因为数组越界而报错，因为ArrayList底层是一个长度动态扩展的数组</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - CopyOnWriteList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_02_CopyOnWriteList</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		 <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// 线程不安全</span></span><br><span class="line"><span class="comment">//		 final List&lt;String&gt; list = new Vector&lt;&gt;(); // 线程安全</span></span><br><span class="line"><span class="comment">//		final List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); // 线程安全</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		Thread[] array = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">100</span>];</span><br><span class="line">		<span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(array.length);</span><br><span class="line">		</span><br><span class="line">		<span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">			array[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							list.add(<span class="string">&quot;value&quot;</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					latch.countDown();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Thread t : array)&#123;</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			latch.await();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;执行时间为 ： &quot;</span> + (end-begin) + <span class="string">&quot;毫秒！&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;List.size() : &quot;</span> + list.size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ArrayList结果：<strong>因为ArrayList是线程不安全的，所以在多线程环境中，可能会丢失数据</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmODE2MmFmYjA4NDQ"></p>
<p>Vector结果：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmODNkYWRhNmYzYjc"></p>
<p>CopyOnWriteArrayList结果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmODQ0ZmVhNmI1Yjc"></p>
<p>CopyOnWriteArrayList是读写分离的，写时复制出一个新的数组，完成插入、修改或者移除操作后将新数组赋值给array，读取时直接读取最新的数组，所以在写操作时，效率非常低（虽然写比较慢，但它在删除数组头和尾还是很快的）<br>从上面三个结果可以看出,CopyOnWriteArrayList虽然保证了线程安全，但它的写操作效率太低了，但相比Vector，并发安全且性能比Vector好，Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，<strong>但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况</strong>，所以CopyOnWriteArrayList是不会存在脏读问题的</p>
<h2 id="4-3-Queue"><a href="#4-3-Queue" class="headerlink" title="4.3 Queue"></a>4.3 Queue</h2><p>常用阻塞队列</p>
<ul>
<li>ArrayBlockingQueue: 一个数组结构组成的有界阻塞队列，按照先进先出原则，要求设定初始大小</li>
<li>LinkedBlockingQueue: 一个由链表结构组成的有界队列，按照先进先出的原则，可以不设置初始大小，默认为Integer.Max_Value(0x7fffffff)<blockquote>
<p>ArrayBlockingQueue只有一个锁，LinkedBlockingQueue用了两个锁</p>
</blockquote>
</li>
<li>PriorityBlockingQueue:一个支持优先级排序的无界阻塞队列，默认按照自然顺序，要么实现compareTo()方法，指定构造方法Comparator</li>
<li>DelayQueue: 一个使用优先级队列实现的无界阻塞队列</li>
<li>SynchronousQueue: 一个不存储元素的阻塞队列</li>
<li>LinkedTransferQueue：一个又链表结构组成的无界阻塞队列</li>
<li>LinkedBlockDeque:一个由链表结构组成的双向阻塞队列，可以从队列的头和尾部插入和移除元素，实现工作的密取</li>
</ul>
<h3 id="4-3-1-ConcurrentLinkedQueue"><a href="#4-3-1-ConcurrentLinkedQueue" class="headerlink" title="4.3.1 ConcurrentLinkedQueue"></a>4.3.1 ConcurrentLinkedQueue</h3><p>基础链表同步队列</p>
<blockquote>
<p><strong>peek() -&gt; 查看queue中的首数据</strong><br><strong>poll() -&gt; 获取queue中的首数据</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - ConcurrentLinkedQueue</span></span><br><span class="line"><span class="comment"> *  队列 - 链表实现的。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_03_ConcurrentLinkedQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向队列中增加10个数据</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			queue.offer(<span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(queue);</span><br><span class="line">		System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// peek() -&gt; 查看queue中的首数据，</span></span><br><span class="line">		System.out.println(<span class="string">&quot;首数据 &quot;</span> + queue.peek());</span><br><span class="line">		System.out.println(<span class="string">&quot;队列长度 &quot;</span>+ queue.size());</span><br><span class="line">		System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">		<span class="comment">// poll() -&gt; 获取queue中的首数据</span></span><br><span class="line">		System.out.println(<span class="string">&quot;首数据 &quot;</span> + queue.peek());</span><br><span class="line">		System.out.println(<span class="string">&quot;队列长度 &quot;</span>+ queue.size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmOTUwNjA2NjgzZDY"></p>
<h3 id="4-3-2-阻塞队列LinkedBlockingQueue"><a href="#4-3-2-阻塞队列LinkedBlockingQueue" class="headerlink" title="4.3.2 阻塞队列LinkedBlockingQueue"></a>4.3.2 阻塞队列LinkedBlockingQueue</h3><p>阻塞队列，队列容量不足自动阻塞，队列容量为0自动阻塞。</p>
<blockquote>
<p> <strong>put &amp; take - 自动阻塞</strong><br> <strong>put自动阻塞， 队列容量满后，自动阻塞</strong><br> <strong>take自动阻塞方法， 队列容量为0后，自动阻塞</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - LinkedBlockingQueue</span></span><br><span class="line"><span class="comment"> *  阻塞容器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_04_LinkedBlockingQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">final</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Test_04_LinkedBlockingQueue</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_04_LinkedBlockingQueue</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						t.queue.put(<span class="string">&quot;value&quot;</span>+t.r.nextInt(<span class="number">1000</span>));</span><br><span class="line">						TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName() + </span><br><span class="line">									<span class="string">&quot; - &quot;</span> + t.queue.take());</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, <span class="string">&quot;consumer&quot;</span>+i).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmOWM3MzA5NmM4ZDY"><br>结果就是一个简单的生产者消费者</p>
<h3 id="4-3-3-BlockingQueue"><a href="#4-3-3-BlockingQueue" class="headerlink" title="4.3.3 BlockingQueue"></a>4.3.3 BlockingQueue</h3><p><strong>底层数组实现的有界队列，当容量不足的时候，有阻塞能力，根据调用API（add&#x2F;put&#x2F;offer）不同，有不同特性</strong><br>这里主要介绍三个api方法add，put，offer  </p>
<ul>
<li>add方法在容量不足的时候，抛出异常。  </li>
<li>put方法在容量不足的时候，阻塞等待。  </li>
<li>offer方法<blockquote>
<p>单参数offer方法，不阻塞。容量不足的时候，返回false。当前新增数据操作放弃。<br>三参数offer方法（offer(value,times,timeunit)），容量不足的时候，阻塞times时长（单位为timeunit），如果在阻塞时长内，有容量空闲，新增数据返回true。如果阻塞时长范围内，无容量空闲，放弃新增数据，返回false。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - ArrayBlockingQueue</span></span><br><span class="line"><span class="comment"> *  有界容器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_05_ArrayBlockingQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">final</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Test_05_ArrayBlockingQueue</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_05_ArrayBlockingQueue</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 1.add method</span></span><br><span class="line">			System.out.println(<span class="string">&quot;add method : &quot;</span> + t.queue.add(<span class="string">&quot;value&quot;</span>+i));</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 2.put method</span></span><br><span class="line"><span class="comment">//			try &#123;</span></span><br><span class="line"><span class="comment">//				t.queue.put(&quot;put&quot;+i);</span></span><br><span class="line"><span class="comment">//			&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//				e.printStackTrace();</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;put method : &quot; + i);</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3.offer method</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;offer method : &quot; + t.queue.offer(&quot;value&quot;+i));</span></span><br><span class="line"><span class="comment">//			try &#123;</span></span><br><span class="line"><span class="comment">//				System.out.println(&quot;offer method : &quot; +</span></span><br><span class="line"><span class="comment">//							t.queue.offer(&quot;value&quot;+i, 1, TimeUnit.SECONDS));</span></span><br><span class="line"><span class="comment">//			&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//				e.printStackTrace();</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(t.queue);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>add方法结果：<strong>容量不足的时候，抛出异常</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmYTUxMDU2NDY5MTg"></p>
<p>put方法结果：<strong>容量不足的时候，阻塞等待</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmYTVhZjYxZGRjZjc"></p>
<p>单&#x2F;多参数offer方法结果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmYWIyZTc3MmUzNTM"><br>单参数offer：<strong>容量不足，直接返回结果，不阻塞</strong><br>多参数offer：<strong>容量不足，阻塞</strong></p>
<h3 id="4-3-4-延时队列DelayQueue"><a href="#4-3-4-延时队列DelayQueue" class="headerlink" title="4.3.4 延时队列DelayQueue"></a>4.3.4 延时队列DelayQueue</h3><p>延时队列。根据比较机制，实现自定义处理顺序的队列。常用于定时任务。<br>如：定时关机。<br>具体示例代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - DelayQueue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_06_DelayQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> BlockingQueue&lt;MyTask_06&gt; queue = <span class="keyword">new</span> <span class="title class_">DelayQueue</span>&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="type">MyTask_06</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask_06</span>(value + <span class="number">2000</span>);</span><br><span class="line">		<span class="type">MyTask_06</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask_06</span>(value + <span class="number">1000</span>);</span><br><span class="line">		<span class="type">MyTask_06</span> <span class="variable">task3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask_06</span>(value + <span class="number">3000</span>);</span><br><span class="line">		<span class="type">MyTask_06</span> <span class="variable">task4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask_06</span>(value + <span class="number">2500</span>);</span><br><span class="line">		<span class="type">MyTask_06</span> <span class="variable">task5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask_06</span>(value + <span class="number">1500</span>);</span><br><span class="line">		</span><br><span class="line">		queue.put(task1);</span><br><span class="line">		queue.put(task2);</span><br><span class="line">		queue.put(task3);</span><br><span class="line">		queue.put(task4);</span><br><span class="line">		queue.put(task5);</span><br><span class="line">		</span><br><span class="line">		System.out.println(queue);</span><br><span class="line">		System.out.println(value);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">			System.out.println(queue.take());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask_06</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> compareValue;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyTask_06</span><span class="params">(<span class="type">long</span> compareValue)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.compareValue = compareValue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 比较大小。自动实现升序</span></span><br><span class="line"><span class="comment">	 * 建议和getDelay方法配合完成。</span></span><br><span class="line"><span class="comment">	 * 如果在DelayQueue是需要按时间完成的计划任务，必须配合getDelay方法完成。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">int</span>)(<span class="built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取计划时长的方法。</span></span><br><span class="line"><span class="comment">	 * 根据参数TimeUnit来决定，如何返回结果值。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unit.convert(compareValue - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Task compare value is : &quot;</span> + <span class="built_in">this</span>.compareValue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmZGIyMTQxODY4ODI"></p>
<h3 id="4-3-5-转移队列LinkedTransferQueue"><a href="#4-3-5-转移队列LinkedTransferQueue" class="headerlink" title="4.3.5 转移队列LinkedTransferQueue"></a>4.3.5 转移队列LinkedTransferQueue</h3><p>这里主要是两个方法的区别，add和transfer  </p>
<ul>
<li>add - 队列会保存数据，不做阻塞等待。</li>
<li>transfer - 是TransferQueue的特有方法。必须有消费者（take()方法的调用者）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - LinkedTransferQueue</span></span><br><span class="line"><span class="comment"> *  转移队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedTransferQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TransferQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_07_TransferQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	TransferQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedTransferQueue</span>&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Test_07_TransferQueue</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_07_TransferQueue</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">			@Override</span></span><br><span class="line"><span class="comment">			public void run() &#123;</span></span><br><span class="line"><span class="comment">				try &#123;</span></span><br><span class="line"><span class="comment">					System.out.println(Thread.currentThread().getName() + &quot; thread begin &quot; );</span></span><br><span class="line"><span class="comment">					System.out.println(Thread.currentThread().getName() + &quot; - &quot; + t.queue.take());</span></span><br><span class="line"><span class="comment">				&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">					e.printStackTrace();</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;, &quot;output thread&quot;).start();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		try &#123;</span></span><br><span class="line"><span class="comment">			TimeUnit.SECONDS.sleep(2);</span></span><br><span class="line"><span class="comment">		&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">			e.printStackTrace();</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		try &#123;</span></span><br><span class="line"><span class="comment">			t.queue.transfer(&quot;test string&quot;);</span></span><br><span class="line"><span class="comment">		&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">			e.printStackTrace();</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					t.queue.transfer(<span class="string">&quot;test string&quot;</span>);</span><br><span class="line">					<span class="comment">// t.queue.add(&quot;test string&quot;);</span></span><br><span class="line">					System.out.println(<span class="string">&quot;add ok&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot; thread begin &quot;</span> );</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + t.queue.take());</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;output thread&quot;</span>).start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
这里的transfer()和take()都是阻塞方法，take先请求接收数据或者transfer先发送数据，都会进行阻塞等待。<br><strong>举个例子，transfer()就相当与手机打电话，当A给B打电话，B必须接收到电话信号接听才能进行通话，否则A会一直等待</strong><br><strong>add()就相当于A给B发短信，短信已经存到了运营商那边，等待B接收，不管发短信时B是否在线</strong></li>
</ul>
<h3 id="4-3-6-SynchronousQueue"><a href="#4-3-6-SynchronousQueue" class="headerlink" title="4.3.6 SynchronousQueue"></a>4.3.6 SynchronousQueue</h3><p>该队列一个容量为0的队列，是一个特殊的TransferQueue，它和TransferQueue很像，但这个队列必须要有消费线程才行<br>又两个方法add,put<br>add方法，无阻塞。若没有消费线程阻塞等待数据，则抛出异常。<br>put方法，有阻塞。若没有消费线程阻塞等待数据，则阻塞。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发容器 - SynchronousQueue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_08_SynchronusQueue</span> &#123;</span><br><span class="line">	</span><br><span class="line">	BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Test_08_SynchronusQueue</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_08_SynchronusQueue</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot; thread begin &quot;</span> );</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + t.queue.take());</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;output thread&quot;</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">			TimeUnit.SECONDS.sleep(3);</span></span><br><span class="line"><span class="comment">		&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">			e.printStackTrace();</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		<span class="comment">// t.queue.add(&quot;test add&quot;);</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t.queue.put(<span class="string">&quot;test put&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot; queue size : &quot;</span> + t.queue.size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将<code>t.queue.add(&quot;test add&quot;);</code>的注释打开，<code>t.queue.put(&quot;test put&quot;);</code>加上注释<br>add方法异常结果： <strong>因为它是一个容量为0的队列</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE3LzE2YmZmZjNmMzY4ZTQwMzA"></p>
<p>更多精彩内容：<a href="https://mrxccc.github.io/">mrxccc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrxccc.github.io/posts/933755ce.html" data-id="cm5kxt8oc0031kku40xod26kq" data-title="同步容器与JUC并发容器的对比与介绍" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Spring-AOP源码解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/f2f19416.html" class="article-date">
  <time class="dt-published" datetime="2019-08-09T01:23:20.000Z" itemprop="datePublished">2019-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/f2f19416.html">Spring-AOP源码解析（案例+解析）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-AOP解释"><a href="#1-AOP解释" class="headerlink" title="1.AOP解释"></a>1.AOP解释</h1><p>摘自百度百科</p>
<blockquote>
<p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
</blockquote>
<h1 id="2-如何使用SpringAOP"><a href="#2-如何使用SpringAOP" class="headerlink" title="2.如何使用SpringAOP"></a>2.如何使用SpringAOP</h1><p>准备工作</p>
<blockquote>
<p> 1、导入aop模块；Spring AOP：(spring-aspects)<br>    2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）<br>    3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行； 		<br>    通知方法：<br>        前置通知(@Before)：logStart：在目标方法(div)运行之前运行<br>         后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）<br>         返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行<br>         异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行<br>         环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）<br>    4、给切面类的目标方法标注何时何地运行（通知注解）；<br>    5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;<br>    6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)<br>    7、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】  </p>
</blockquote>
<p><strong>切面类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class LogAspects &#123;</span><br><span class="line"></span><br><span class="line">    //抽取公共的切入点表达式</span><br><span class="line">    //1、本类引用</span><br><span class="line">    //2、其他的切面引用</span><br><span class="line">    @Pointcut(&quot;execution(public int com.bernard.aop.MathCalculator.*(..))&quot;)</span><br><span class="line">    public void pointCut()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入）</span><br><span class="line">    @Before(&quot;pointCut()&quot;)</span><br><span class="line">    public void logStart(JoinPoint joinPoint)&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;运行。。。@Before:参数列表是：&#123;&quot;+ Arrays.asList(args)+&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;com.bernard.aop.LogAspects.pointCut()&quot;)</span><br><span class="line">    public void logEnd(JoinPoint joinPoint)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;结束。。。@After&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //JoinPoint一定要出现在参数表的第一位</span><br><span class="line">    @AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;)</span><br><span class="line">    public void logReturn(JoinPoint joinPoint,Object result)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;正常返回。。。@AfterReturning:运行结果：&#123;&quot;+result+&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;exception&quot;)</span><br><span class="line">    public void logException(JoinPoint joinPoint,Exception exception)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;异常。。。异常信息：&#123;&quot;+exception+&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;pointCut()&quot;)</span><br><span class="line">    public Object logAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;Around: 执行目标方法之前&quot;);</span><br><span class="line">        Object proceed = proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(&quot;Around: 执行目标方法之后&quot;);</span><br><span class="line">        return proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">@Configuration</span><br><span class="line">public class MainConfigOfAOP &#123;</span><br><span class="line"></span><br><span class="line">    //业务逻辑类加入容器中</span><br><span class="line">    @Bean</span><br><span class="line">    public MathCalculator calculator()&#123;</span><br><span class="line">        return new MathCalculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //切面类加入到容器中</span><br><span class="line">    @Bean</span><br><span class="line">    public LogAspects logAspects()&#123;</span><br><span class="line">        return new LogAspects();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>业务逻辑类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MathCalculator &#123;</span><br><span class="line"></span><br><span class="line">    public int div(int i,int j)&#123;</span><br><span class="line">        System.out.println(&quot;MathCalculator...div...&quot;);</span><br><span class="line">        return i/j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> public class IOCTest_AOP &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test01()&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);</span><br><span class="line"></span><br><span class="line">        //1、不要自己创建对象</span><br><span class="line">//		MathCalculator mathCalculator = new MathCalculator();</span><br><span class="line">//		mathCalculator.div(1, 1);</span><br><span class="line">        MathCalculator mathCalculator = applicationContext.getBean(MathCalculator.class);</span><br><span class="line"></span><br><span class="line">        mathCalculator.div(1, 1);</span><br><span class="line"></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWNiMGY3NTJlYzcwNQ"></p>
<h1 id="3-EnableAspectJAutoProxy到底干了啥？"><a href="#3-EnableAspectJAutoProxy到底干了啥？" class="headerlink" title="3.@EnableAspectJAutoProxy到底干了啥？"></a>3.@EnableAspectJAutoProxy到底干了啥？</h1><p>开启SrpingAOP功能时，有使用一个注解为@EnableAspectJAutoProxy，查看该注解时，可以看到这个注解Import了一个类<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY4ZWMyMzlhZTBmMA"><br>跟进这个类，可以看到他是继承了ImportBeanDefinitionRegistrar，并且实现了ImportBeanDefinitionRegistrar的registerBeanDefinitions()方法，为了是导入自定义组件</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY5MGMwYWMwYWFlNA"></p>
<p>再跟进这个方法<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY5M2VjMzJiNGM1ZA"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY5YzhhNjRlZTBlMQ"><br>整个@EnableAspectJAutoProxy注解作用就是为了<strong>注册一个id为<code>org.springframework.aop.config.internalAutoProxyCreator</code>，class为<code>AnnotationAwareAspectJAutoProxyCreator.class</code>的BeanDefinition</strong></p>
<p>AnnotationAwareAspectJAutoProxyCreatord结构<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTZhNGQxYWYwOTU2MA"></p>
<p>在它的所有父类接口中，有一个抽象类AbstractAutoProxyCreator  </p>
<blockquote>
<p>继承了：ProxyProcessorSupport类<br>实现了：SmartInstantiationAwareBeanPostProcessor和BeanFactoryAware接口</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTZiMTJiMTRlNDY2ZQ"></p>
<p><strong>具体类图如下：</strong><br>主要为了说明类之间的继承关系，方法的返回值和参数未在图中列出<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWNhZThhNjk3MTYxZA"></p>
<p>这里，我们要重点关注两个实现  </p>
<ul>
<li>SmartInstantiationAwareBeanPostProcessor:后置处理器（在我们bean初始化完成前后要做的事情）<br>postProcessBeforeInstantiation()和postProcessAfterInstantiation()两个方法做了什么事？</li>
<li>AbstractAdvisorAutoProxyCreator重写的setBeanFactory()做了什么事？</li>
<li>AnnotationAwareAspectJAutoProxyCreator的initBeanFactory做了什么事？</li>
</ul>
<p><strong>重点：AnnotationAwareAspectJAutoProxyCreator这个类是贯穿SpringAOP整个功能的类</strong><br><strong>重点：AnnotationAwareAspectJAutoProxyCreator这个类是贯穿SpringAOP整个功能的类</strong><br><strong>重点：AnnotationAwareAspectJAutoProxyCreator这个类是贯穿SpringAOP整个功能的类</strong>  </p>
<h1 id="4-Spring的refresh"><a href="#4-Spring的refresh" class="headerlink" title="4 Spring的refresh()"></a>4 Spring的refresh()</h1><p>我们进入AnnotationConfigApplicationContext的构造方法，this()和register(annotatedClasses)主要初始化spring的基础组件和<br>注册一个或多个要处理的带注释的类，AOP功能主要在refresh()方法<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWNiY2I3MDk3YzJkZg"></p>
<p>进入refresh()，里面的逻辑有很多，但Spring-AOP的实现主要看两个方法</p>
<blockquote>
<p>registerBeanPostProcessors(beanFactory);  &#x2F;&#x2F; 注册BeanPostProcessor（Bean的后置处理器）<br>finishBeanFactoryInitialization(beanFactory); &#x2F;&#x2F; 初始化所有剩下的单实例bean；  </p>
</blockquote>
<p>因为AnnotationAwareAspectJAutoProxyCreator也是一个BeanPostProcessor，所以AnnotationAwareAspectJAutoProxyCreator的注册就是在registerBeanPostProcessors(beanFactory)方法中实现的，在这一节中，会分很多小节，对registerBeanPostProcessors和finishBeanFactoryInitialization两个方法中的细节进行介绍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">        synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">            //1 刷新前的预处理</span><br><span class="line">            prepareRefresh();</span><br><span class="line">            //2 获取BeanFactory；刚创建的默认DefaultListableBeanFactory</span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">            //3 BeanFactory的预准备工作（BeanFactory进行一些设置）</span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 4 BeanFactory准备工作完成后进行的后置处理工作；</span><br><span class="line">                 // 4.1）、抽象的方法，当前未做处理。子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置</span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line">        /**************************以上是BeanFactory的创建及预准备工作  ****************/</span><br><span class="line">             </span><br><span class="line">                // 5 执行BeanFactoryPostProcessor的方法；</span><br><span class="line">                //BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的；</span><br><span class="line">                //它的重要两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor</span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">                //6 注册BeanPostProcessor（Bean的后置处理器）</span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line">                // 7 initMessageSource();初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；</span><br><span class="line">                initMessageSource();</span><br><span class="line">                // 8 初始化事件派发器</span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line">                // 9 子类重写这个方法，在容器刷新的时候可以自定义逻辑；</span><br><span class="line">                onRefresh();</span><br><span class="line">                // 10 给容器中将所有项目里面的ApplicationListener注册进来</span><br><span class="line">                registerListeners();</span><br><span class="line">                // 11.初始化所有剩下的单实例bean；</span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                // 12.完成BeanFactory的初始化创建工作；IOC容器就创建完成；</span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (BeansException ex) &#123;</span><br><span class="line">                if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                            &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">                &#125;</span><br><span class="line">                // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">                destroyBeans();</span><br><span class="line">                // Reset &#x27;active&#x27; flag.</span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line">                // Propagate exception to caller.</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                // Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">                // might not ever need metadata for singleton beans anymore...</span><br><span class="line">                resetCommonCaches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-registerBeanPostProcessors方法"><a href="#4-1-registerBeanPostProcessors方法" class="headerlink" title="4.1 registerBeanPostProcessors方法"></a>4.1 registerBeanPostProcessors方法</h2><p>registerBeanPostProcessors()的主要作用是注册bean的后置处理器来方便拦截bean的创建<br>下面的源码中，我对一些关键点都做了注释，也会对一些关键方法单独做一个小节来介绍</p>
<ul>
<li>1）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWQxNzk3ZDhkNzJlOQ"></li>
</ul>
<blockquote>
<p>基于章节2的测试，从截图看出，ioc容器有四个BeanPostProcessor<br>AutowiredAnnotationBeanPostProcessor(处理被@Autowired注解修饰的bean并注入)<br>RequiredAnnotationBeanPostProcessor(处理被@Required注解修饰的方法)<br>CommonAnnotationBeanPostProcessor(处理@PreDestroy、@PostConstruct、@Resource等多个注解的作用)等<br>AnnotationAwareAspectJAutoProxyCreator(处理@EnableAspectJAutoProxy注解，也就是AOP)  </p>
</blockquote>
<ul>
<li><pre><code>2）、给容器中加别的BeanPostProcessor
</code></pre>
</li>
<li><pre><code>3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor
</code></pre>
</li>
<li><pre><code>4）、再给容器中注册实现了Ordered接口的BeanPostProcessor  
</code></pre>
</li>
<li><pre><code>5）、注册没实现优先级接口的BeanPostProcessor  
</code></pre>
</li>
<li><pre><code>6）、把BeanPostProcessor注册到BeanFactory中；
</code></pre>
</li>
</ul>
<p>在3、4、5步骤中，注册BeanPostProcessor的时候都会调用beanFactory.getBean(ppName, BeanPostProcessor.class)方法，beanFactory.getBean方法会着重介绍，bean的获取和创建都是基于这个方法<br>AnnotationAwareAspectJAutoProxyCreator就是在第4步创建的，因为它的父类ProxyProcessorSupport实现了Ordered接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line"></span><br><span class="line">        // 1.先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor</span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Register BeanPostProcessorChecker that logs an info message when</span><br><span class="line">		// a bean is created during BeanPostProcessor instantiation, i.e. when</span><br><span class="line">		// a bean is not eligible for getting processed by all BeanPostProcessors.</span><br><span class="line">		// 2.给容器中加其他的BeanPostProcessor</span><br><span class="line">		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">		</span><br><span class="line">		// 3.优先注册实现了PriorityOrdered接口的BeanPostProcessor；</span><br><span class="line">		// Separate between BeanPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">			    </span><br><span class="line">			    // 3.1在beanFactory中获取BeanPostProcessor</span><br><span class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// First, register the BeanPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">		</span><br><span class="line">		// 4.优先注册实现了PriorityOrdered接口的BeanPostProcessor</span><br><span class="line">		// Next, register the BeanPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">		</span><br><span class="line">		// 5.注册没实现优先级接口的BeanPostProcessor</span><br><span class="line">		// Now, register all regular BeanPostProcessors.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">        // 6）、把BeanPostProcessor注册到BeanFactory中；</span><br><span class="line">		// Finally, re-register all internal BeanPostProcessors.</span><br><span class="line">		sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Re-register post-processor for detecting inner beans as ApplicationListeners,</span><br><span class="line">		// moving it to the end of the processor chain (for picking up proxies etc).</span><br><span class="line">		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>大致脑图如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmFjZjJmYTNmNzkwYw"></p>
<h2 id="4-2-getBean"><a href="#4-2-getBean" class="headerlink" title="4.2 getBean"></a>4.2 getBean</h2><p>AnnotationAwareAspectJAutoProxyCreator是一个BeanPostProcessor<br>注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中；<br>这里以AnnotationAwareAspectJAutoProxyCreator为例：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzUvMTZjNWQ5MDIxMTE2MTZlOA"><br>从beanFactory.getBean()方法获取bean实例的步骤大致如下：</p>
<ul>
<li>1）、创建Bean的实例:AbstractBeanFactory.getBean()-&gt;doGetBean()<ul>
<li>1)、将创建的Bean添加到缓存中singletonObjects(),如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）</li>
<li>2)、缓存中获取不到，开始Bean的创建对象流程</li>
<li>3)、标记当前bean已经被创建</li>
<li>4)、获取Bean的定义信息</li>
<li>5)、获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来 </li>
<li>6)、启动单实例的bean的创建流程</li>
<li>7)、创建Bean ,见4.3<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,</span><br><span class="line">			@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		final String beanName = transformedBeanName(name);</span><br><span class="line">		Object bean;</span><br><span class="line">        </span><br><span class="line">        // 1)、将创建的Bean添加到缓存中singletonObjects(),如果没有获取到创建bean </span><br><span class="line">		// Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">					logger.debug(&quot;Returning eagerly cached instance of singleton bean &#x27;&quot; + beanName +</span><br><span class="line">							&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					logger.debug(&quot;Returning cached instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">		&#125;</span><br><span class="line">        // 2)、缓存中获取不到，开始Bean的创建对象流程</span><br><span class="line">		else &#123;</span><br><span class="line">			// Fail if we&#x27;re already creating this bean instance:</span><br><span class="line">			// We&#x27;re assumably within a circular reference.</span><br><span class="line">			if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			//  获取父beanFatory 检查这个bean是否创建了</span><br><span class="line">			// Check if bean definition exists in this factory.</span><br><span class="line">			BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">			if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				// Not found -&gt; check parent.</span><br><span class="line">				String nameToLookup = originalBeanName(name);</span><br><span class="line">				if (parentBeanFactory instanceof AbstractBeanFactory) &#123;</span><br><span class="line">					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">							nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">				&#125;</span><br><span class="line">				else if (args != null) &#123;</span><br><span class="line">					// Delegation to parent with explicit args.</span><br><span class="line">					return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					// No args -&gt; delegate to standard getBean method.</span><br><span class="line">					return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 3)、标记当前bean已经被创建</span><br><span class="line">			if (!typeCheckOnly) &#123;</span><br><span class="line">				markBeanAsCreated(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">			    //  4)、获取Bean的定义信息</span><br><span class="line">				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">				checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">				</span><br><span class="line">				// 5)、获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来 </span><br><span class="line">				// Guarantee initialization of beans that the current bean depends on.</span><br><span class="line">				String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">				if (dependsOn != null) &#123;</span><br><span class="line">					for (String dep : dependsOn) &#123;</span><br><span class="line">						if (isDependent(beanName, dep)) &#123;</span><br><span class="line">							throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">									&quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dep + &quot;&#x27;&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">						registerDependentBean(dep, beanName);</span><br><span class="line">						try &#123;</span><br><span class="line">							getBean(dep);</span><br><span class="line">						&#125;</span><br><span class="line">						catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">							throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">									&quot;&#x27;&quot; + beanName + &quot;&#x27; depends on missing bean &#x27;&quot; + dep + &quot;&#x27;&quot;, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 6)、启动单实例的bean的创建流程</span><br><span class="line">				if (mbd.isSingleton()) &#123;</span><br><span class="line">				    // //获取到单实例bean后，添加到缓存中 singletonObjects（）</span><br><span class="line">					sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">						try &#123;</span><br><span class="line">						    // 7)、创建单实例Bean ,见4.2.1</span><br><span class="line">							return createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						catch (BeansException ex) &#123;</span><br><span class="line">							// Explicitly remove instance from singleton cache: It might have been put there</span><br><span class="line">							// eagerly by the creation process, to allow for circular reference resolution.</span><br><span class="line">							// Also remove any beans that received a temporary reference to the bean.</span><br><span class="line">							destroySingleton(beanName);</span><br><span class="line">							throw ex;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				else if (mbd.isPrototype()) &#123;</span><br><span class="line">					// It&#x27;s a prototype -&gt; create a new instance.</span><br><span class="line">					Object prototypeInstance = null;</span><br><span class="line">					try &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					finally &#123;</span><br><span class="line">						afterPrototypeCreation(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				else &#123;</span><br><span class="line">					String scopeName = mbd.getScope();</span><br><span class="line">					final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">					if (scope == null) &#123;</span><br><span class="line">						throw new IllegalStateException(&quot;No Scope registered for scope name &#x27;&quot; + scopeName + &quot;&#x27;&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					try &#123;</span><br><span class="line">						Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">							beforePrototypeCreation(beanName);</span><br><span class="line">							try &#123;</span><br><span class="line">								return createBean(beanName, mbd, args);</span><br><span class="line">							&#125;</span><br><span class="line">							finally &#123;</span><br><span class="line">								afterPrototypeCreation(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">					&#125;</span><br><span class="line">					catch (IllegalStateException ex) &#123;</span><br><span class="line">						throw new BeanCreationException(beanName,</span><br><span class="line">								&quot;Scope &#x27;&quot; + scopeName + &quot;&#x27; is not active for the current thread; consider &quot; +</span><br><span class="line">								&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">								ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Check if required type matches the type of the actual bean instance.</span><br><span class="line">		if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">				if (convertedBean == null) &#123;</span><br><span class="line">					throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">				&#125;</span><br><span class="line">				return convertedBean;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (TypeMismatchException ex) &#123;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;Failed to convert bean &#x27;&quot; + name + &quot;&#x27; to required type &#x27;&quot; +</span><br><span class="line">							ClassUtils.getQualifiedName(requiredType) + &quot;&#x27;&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return (T) bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><pre><code>2）、populateBean；给bean的各种属性赋值
</code></pre>
</li>
<li><pre><code>3）、initializeBean：初始化bean；
</code></pre>
<ul>
<li><pre><code>1）、invokeAwareMethods()：处理Aware接口的方法回调
</code></pre>
</li>
<li>2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）</li>
<li>3）、invokeInitMethods()；执行自定义的初始化方法</li>
<li>4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）；</li>
</ul>
</li>
<li>4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；–&gt;aspectJAdvisorsBuilder</li>
</ul>
<h3 id="4-2-1-createBean"><a href="#4-2-1-createBean" class="headerlink" title="4.2.1 createBean"></a>4.2.1 createBean</h3><p>AbstractAutowireCapableBeanFactory.createBean() 这个类中，有以下几个步骤：</p>
<ul>
<li>1)、解析bean的类型</li>
<li>2、让BeanPostProcessor先拦截返回代理对象–&gt;调用resolveBeforeInstantiation方法</li>
<li>3)、没有对象,创建一个bean，调用doCreateBean方法</li>
<li>4)、返回创建的bean <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">			throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">		</span><br><span class="line">		 // 1)、解析bean的类型</span><br><span class="line">		// Make sure bean class is actually resolved at this point, and</span><br><span class="line">		// clone the bean definition in case of a dynamically resolved Class</span><br><span class="line">		// which cannot be stored in the shared merged bean definition.</span><br><span class="line">		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class="line">			mbdToUse = new RootBeanDefinition(mbd);</span><br><span class="line">			mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Prepare method overrides.</span><br><span class="line">		try &#123;</span><br><span class="line">			mbdToUse.prepareMethodOverrides();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">					beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		    // 2、让BeanPostProcessor先拦截返回代理对象</span><br><span class="line">			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br><span class="line">			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">			if (bean != null) &#123;</span><br><span class="line">				return bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">					&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		    //  3)、没有对象  创建一个bean</span><br><span class="line">			Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			// 4)、返回创建的bean </span><br><span class="line">			return beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">			// A previously detected exception with proper bean creation context already,</span><br><span class="line">			// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-2-resolveBeforeInstantiation返回代理对象"><a href="#4-2-2-resolveBeforeInstantiation返回代理对象" class="headerlink" title="4.2.2 resolveBeforeInstantiation返回代理对象"></a>4.2.2 resolveBeforeInstantiation返回代理对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         // 2、让BeanPostProcessor先拦截返回代理对象</span><br><span class="line">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">if (bean != null) &#123;</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>resolveBeforeInstantiation方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">	protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">		Object bean = null;</span><br><span class="line">		if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">			// Make sure bean class is actually resolved at this point.</span><br><span class="line">			if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">				Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">				if (targetType != null) &#123;</span><br><span class="line">					bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">					if (bean != null) &#123;</span><br><span class="line">						bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.beforeInstantiationResolved = (bean != null);</span><br><span class="line">		&#125;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>applyBeanPostProcessorsBeforeInstantiation方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">	protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">		for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">				if (result != null) &#123;</span><br><span class="line">					return result;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>这里源码的注释是“让beanpostprocessor有机会返回代理而不是目标bean实例”，如果成功返回代理对象，则直接返回，否则再执行doCreateBean来创建实例。从开始进入到applyBeanPostProcessorsBeforeInstantiation这个方法中，会但是对于AbstractAutoProxyCreator这个类来说，在执行applyBeanPostProcessorsBeforeInstantiation方法时，它并没有创建，所以并不会执行AbstractAutoProxyCreator的applyBeanPostProcessorsBeforeInstantiation方法和applyBeanPostProcessorsAfterInitialization，返回null,在后面的逻辑中，如果resolveBeforeInstantiation返回null,会执行doCreateBean方法，创建AbstractAutoProxyCreator</p>
<h3 id="4-2-3-doCreateBean创建实例"><a href="#4-2-3-doCreateBean创建实例" class="headerlink" title="4.2.3 doCreateBean创建实例"></a>4.2.3 doCreateBean创建实例</h3><p>当resolveBeforeInstantiation返回null时，执行doCreateBean<br>doCreateBean主要流程是：</p>
<ul>
<li>1）、创建Bean的实例</li>
<li><pre><code>2）、populateBean；给bean的各种属性赋值
</code></pre>
</li>
<li><pre><code>3）、initializeBean：初始化bean；
</code></pre>
</li>
</ul>
<p>它的主要步骤在于initializeBean方法上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</span><br><span class="line">			throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		// Instantiate the bean.</span><br><span class="line">		BeanWrapper instanceWrapper = null;</span><br><span class="line">		if (mbd.isSingleton()) &#123;</span><br><span class="line">		</span><br><span class="line">		     // 1）、【创建Bean实例】利用工厂方法或者对象的构造器创建出Bean实例；</span><br><span class="line">			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		if (instanceWrapper == null) &#123;</span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		final Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">		if (beanType != NullBean.class) &#123;</span><br><span class="line">			mbd.resolvedTargetType = beanType;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Allow post-processors to modify the merged bean definition.</span><br><span class="line">		synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">			if (!mbd.postProcessed) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">				    //调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType,</span><br><span class="line">				    beanName);</span><br><span class="line">				    //判断是否为：MergedBeanDefinitionPostProcessor 类型的，如果是，调用方法</span><br><span class="line">				    //MergedBeanDefinitionPostProcessor 后置处理器是在bean实例换之后调用的</span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Throwable ex) &#123;</span><br><span class="line">					throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">							&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.postProcessed = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">         // 判断bean 是否为单实例的，如果是单实例的添加到缓存中</span><br><span class="line">		// Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">		// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">						&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			 //添加bean到缓存中</span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Initialize the bean instance.</span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		try &#123;</span><br><span class="line">		    // 2)、给bean的各种属性赋值</span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			</span><br><span class="line">			// 3)、初始化bean</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">				throw (BeanCreationException) ex;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				throw new BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">			if (earlySingletonReference != null) &#123;</span><br><span class="line">				if (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">					for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								&quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +</span><br><span class="line">								&quot;wrapped. This means that said other beans do not use the final version of the &quot; +</span><br><span class="line">								&quot;bean. This is often the result of over-eager type matching - consider using &quot; +</span><br><span class="line">								&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Register bean as disposable.</span><br><span class="line">		try &#123;</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-initializeBean初始化bean"><a href="#4-3-2-initializeBean初始化bean" class="headerlink" title="4.3.2 initializeBean初始化bean"></a>4.3.2 initializeBean初始化bean</h3><ul>
<li>1）、invokeAwareMethods()：处理Aware接口的方法回调  </li>
<li>2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）  </li>
<li><pre><code>3）、invokeInitMethods()；执行自定义的初始化方法    
</code></pre>
</li>
<li><pre><code>4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）    
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">				invokeAwareMethods(beanName, bean);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">		// 1)、处理Aware接口的方法回调  </span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">		    // 2）、应用后置处理器的postProcessBeforeInitialization（）</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		    // 3）、执行自定义的初始化方法</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					(mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">		    // 4）、执行后置处理器的postProcessAfterInitialization（） </span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-finishBeanFactoryInitialization"><a href="#5-finishBeanFactoryInitialization" class="headerlink" title="5 finishBeanFactoryInitialization"></a>5 finishBeanFactoryInitialization</h1><p>第四章节主要是介绍创建和注册AnnotationAwareAspectJAutoProxyCreator后置处理器的过程<br>而finishBeanFactoryInitialization(beanFactory)是完成BeanFactory初始化工作、创建剩余的非懒加载单实例bean，也就是我们的业务bean：MathCalculator的创建过程是在这一步完成的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Finish the initialization of this context&#x27;s bean factory,</span><br><span class="line">	 * initializing all remaining singleton beans.</span><br><span class="line">	 */</span><br><span class="line">	protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">	     // 类型装换器</span><br><span class="line">		// Initialize conversion service for this context.</span><br><span class="line">		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">			beanFactory.setConversionService(</span><br><span class="line">					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Register a default embedded value resolver if no bean post-processor</span><br><span class="line">		// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">		// at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">		if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">			beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span><br><span class="line">		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">		for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">			getBean(weaverAwareName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Stop using the temporary ClassLoader for type matching.</span><br><span class="line">		beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">		// Allow for caching all bean definition metadata, not expecting further changes.</span><br><span class="line">		beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">		// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>beanFactory.preInstantiateSingletons()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">		if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">			this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">		List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">		// Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				if (isFactoryBean(beanName)) &#123;</span><br><span class="line">					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					if (bean instanceof FactoryBean) &#123;</span><br><span class="line">						final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">						boolean isEagerInit;</span><br><span class="line">						if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">							isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">											((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">									getAccessControlContext());</span><br><span class="line">						&#125;</span><br><span class="line">						else &#123;</span><br><span class="line">							isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">									((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">						&#125;</span><br><span class="line">						if (isEagerInit) &#123;</span><br><span class="line">							getBean(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">				    // 调用父类AbstractBeanFactory的doGetBean方法</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Trigger post-initialization callback for all applicable beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			Object singletonInstance = getSingleton(beanName);</span><br><span class="line">			if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">				final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">				if (System.getSecurityManager() != null) &#123;</span><br><span class="line">					AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">						smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">						return null;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法里面关注最后一个方法，beanFactory.preInstantiateSingletons()的作用就是创建剩余的非懒加载单实例bean，如下图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmIwNDQzNmM4NDdjNw"><br>我们的业务calculator，LogAspects就是在这里创建的，会调用父类的AbstractBeanFactory的doGetBean方法，执行流程和章节4.2的getBean方法是一个流程</p>
<p>但是创建calculator，LogAspects和创建AnnotationAwareAspectJAutoProxyCreator是有点不同的，在4.2.2章节，我们有提到，创建bean时，resolveBeforeInstantiation(beanName, mbdToUse)方法会尝试返回它的代理对象返回，否则执行doCreateBean创建bean对象，因为AnnotationAwareAspectJAutoProxyCreator已经在第4章节的registerBeanPostProcessors方法中所创建，所以在每一个bean创建之前，都会调用AnnotationAwareAspectJAutoProxyCreator的postProcessBeforeInstantiation()方法和postProcessAfterInitialization方法</p>
<h2 id="5-1-postProcessBeforeInstantiation"><a href="#5-1-postProcessBeforeInstantiation" class="headerlink" title="5.1 postProcessBeforeInstantiation()"></a>5.1 postProcessBeforeInstantiation()</h2><p><strong>AnnotationAwareAspectJAutoProxyCreator的父类AbstractAutoProxyCreator的postProcessBeforeInstantiation方法如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">		if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		    // 1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）</span><br><span class="line">			if (this.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">			// 2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean， 			或者是否是切面（@Aspect）</span><br><span class="line">			// 3）、是否需要跳过</span><br><span class="line">			if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">				this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Create proxy here if we have a custom TargetSource.</span><br><span class="line">		// Suppresses unnecessary default instantiation of the target bean:</span><br><span class="line">		// The TargetSource will handle target instances in a custom fashion.</span><br><span class="line">		TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">		if (targetSource != null) &#123;</span><br><span class="line">			if (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">				this.targetSourcedBeans.add(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">			Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">			this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">			return proxy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjMDBjNGIzMzQzMg"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjNDQ5YjE1YjFiMg"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjNTMyNDEzNjhlMA"><br>这个方法以MathCalculator和LogAspect的创建为例子：</p>
<ul>
<li>1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean），第一次创建肯定是没有的</li>
<li><pre><code>2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean， 			或者是否是切面（@Aspect）
</code></pre>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjNmEzZDk5YjE5Zg"></li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjN2I5OGRkYTVmNg"></p>
<ul>
<li><pre><code>3）、是否需要跳过
</code></pre>
<ul>
<li><pre><code>1）、获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】
       每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；
       判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true
</code></pre>
</li>
<li><pre><code>2）、永远返回false
</code></pre>
</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjYWYzODA1YWM5Ng"></p>
<h2 id="5-2-postProcessAfterInitialization"><a href="#5-2-postProcessAfterInitialization" class="headerlink" title="5.2 postProcessAfterInitialization()"></a>5.2 postProcessAfterInitialization()</h2><p>AnnotationAwareAspectJAutoProxyCreator的父类AbstractAutoProxyCreator的postProcessAfterInitialization方法是在<br>章节4.3.2 initializeBean初始化bean的applyBeanPostProcessorsAfterInitialization调用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Initialize the given bean instance, applying factory callbacks</span><br><span class="line">	 * as well as init methods and bean post processors.</span><br><span class="line">	 * &lt;p&gt;Called from &#123;@link #createBean&#125; for traditionally defined beans,</span><br><span class="line">	 * and from &#123;@link #initializeBean&#125; for existing bean instances.</span><br><span class="line">	 * @param beanName the bean name in the factory (for debugging purposes)</span><br><span class="line">	 * @param bean the new bean instance we may need to initialize</span><br><span class="line">	 * @param mbd the bean definition that the bean was created with</span><br><span class="line">	 * (can also be &#123;@code null&#125;, if given an existing bean instance)</span><br><span class="line">	 * @return the initialized bean instance (potentially wrapped)</span><br><span class="line">	 * @see BeanNameAware</span><br><span class="line">	 * @see BeanClassLoaderAware</span><br><span class="line">	 * @see BeanFactoryAware</span><br><span class="line">	 * @see #applyBeanPostProcessorsBeforeInitialization</span><br><span class="line">	 * @see #invokeInitMethods</span><br><span class="line">	 * @see #applyBeanPostProcessorsAfterInitialization</span><br><span class="line">	 */</span><br><span class="line">	protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">				invokeAwareMethods(beanName, bean);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">		// 注意：这里执行的postProcessBeforeInstantiation并不是5.1章节所执行的bean,他直接返回了传过去的wrappedBean</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					(mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>postProcessAfterInitialization()代码如下：</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJlMDhhNGY0ZDg0Mw"></p>
<p>可以看出，返回了一个wrapIfNecessary(bean, beanName, cacheKey);&#x2F;&#x2F;如果需要包装<br><strong>wrapIfNecessary(bean, beanName, cacheKey);代码如下</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJlMzkzOWFlNTIzYw"></p>
<p>前面的三个if在5.1已经有过介绍，主要看<code>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null)</code>，获取当前bean的所有增强器（通知方法），这里的当前bean也就是MathCalculator，这个方法做了如下几个步骤</p>
<ul>
<li><pre><code>1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）
</code></pre>
</li>
<li><pre><code>2、获取到能在bean使用的增强器。
</code></pre>
</li>
<li><pre><code>3、给增强器排序
</code></pre>
</li>
<li><pre><code>4、保存当前bean在advisedBeans中；
</code></pre>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzgvMTZjNmYxMTcyM2RiMTIwZQ"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzgvMTZjNmYwMjEyZjlmYjg3NA"></li>
</ul>
<p>如果当前bean需要增强，会创建当前bean的代理对象：<code>Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</code><br>protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,<br>            @Nullable Object[] specificInterceptors, TargetSource targetSource) {</p>
<pre><code>    if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;
        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
    &#125;

    ProxyFactory proxyFactory = new ProxyFactory();
    proxyFactory.copyFrom(this);

    if (!proxyFactory.isProxyTargetClass()) &#123;
        if (shouldProxyTargetClass(beanClass, beanName)) &#123;
            proxyFactory.setProxyTargetClass(true);
        &#125;
        else &#123;
            evaluateProxyInterfaces(beanClass, proxyFactory);
        &#125;
    &#125;
    // 1）、获取所有增强器（通知方法）
    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    2）、保存到proxyFactory
    proxyFactory.addAdvisors(advisors);
    proxyFactory.setTargetSource(targetSource);
    customizeProxyFactory(proxyFactory);

    proxyFactory.setFrozen(this.freezeProxy);
    if (advisorsPreFiltered()) &#123;
        proxyFactory.setPreFiltered(true);
    &#125;
    3）、创建代理对象：Spring自动决定
    return proxyFactory.getProxy(getProxyClassLoader());
&#125;
</code></pre>
<ul>
<li><pre><code>1）、获取所有增强器（通知方法）
</code></pre>
</li>
<li><pre><code>2）、保存到proxyFactory
</code></pre>
</li>
<li><pre><code>3）、创建代理对象：Spring自动决定
</code></pre>
</li>
</ul>
<p>更多精彩内容：<a href="https://mrxccc.github.io/">mrxccc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrxccc.github.io/posts/f2f19416.html" data-id="cm5kxt8o6002ikku41uij2kgj" data-title="Spring-AOP源码解析（案例+解析）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JUC-各种线程池汇总" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/fcbd1efb.html" class="article-date">
  <time class="dt-published" datetime="2019-08-09T01:22:32.000Z" itemprop="datePublished">2019-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/fcbd1efb.html">JUC-各种线程池汇总</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-准备知识"><a href="#1-准备知识" class="headerlink" title="1 准备知识"></a>1 准备知识</h1><p>介绍线程池之前先简要了解一下Executor，ExecutorService，Future，Callable，Executors是什么，和线程池又有什么关系</p>
<h2 id="1-1-Executor"><a href="#1-1-Executor" class="headerlink" title="1.1 Executor"></a>1.1 Executor</h2><p>它是线程池顶级接口。它定义了一个方法**void execute(Runnable)**。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzAzMDQ5OTMyNjg5MTc"><br>这个方法是用于处理任务的一个服务方法，调用者提供Runnable接口的实现，线程池通过线程执行这个Runnable，该服务方法是无返回值的</p>
<h2 id="1-2-ExecutorService"><a href="#1-2-ExecutorService" class="headerlink" title="1.2 ExecutorService"></a>1.2 ExecutorService</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzAzMGUyYWNkMDI3NzI"><br>ExecutorService是Executor接口的子接口，它提供了一个新的服务方法submit，是有返回值的，返回值类型为Future类型（<strong>关于Future见1.3</strong>），它提供返回值主要是由Callable的call方法提供返回值（<strong>Callable见1.4</strong>） ，所有的线程池类型都实现这个接口</p>
<h2 id="1-3-Future"><a href="#1-3-Future" class="headerlink" title="1.3 Future"></a>1.3 Future</h2><p>顾名思义，Future-&gt;未来,代表线程任务执行结束后的结果。<br>获取线程执行结果的方式是通过get方法获取的，get有两种方式，有参和无参<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzAzMWQyMzU5ZWQyOTY"><br>无参<code>T get()</code>-&gt;阻塞等待线程执行结束，并得到结果。<br>有参<code>T get(long, TimeUnit)</code>-&gt;阻塞固定时长，等待线程执行结束后的结果，如果在阻塞时长范围内，线程未执行结束，抛出异常。</p>
<h2 id="1-4-Callable"><a href="#1-4-Callable" class="headerlink" title="1.4 Callable"></a>1.4 Callable</h2><p> Callable类似Runnable接口，它有一个call方法，它的作用和Runnable中的run方法完全一致，但也有区别<br> Callable的call-&gt;有返回值，可以抛出任意异常<br> Runnable的run-&gt; 无返回值，不能抛出未检查的异常<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzAzMjE0MTcwMjYxNTU"><br>call方法的返回值就是Future中get方法的返回值</p>
<h2 id="1-5-Executors"><a href="#1-5-Executors" class="headerlink" title="1.5 Executors"></a>1.5 Executors</h2><p>Executors是一个工具类，类似Collection和Collections的关系，可以更简单的创建若干种线程池，通过Executors可以直接得到想要的线程池</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzAzMjliNjBmZDU1ZTY"></p>
<h1 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2 线程池"></a>2 线程池</h1><p>线程池可以自动创建也可以手动创建，自动创建体现在Executors工具类中，常见的可以创建newFixedThreadPool、newCachedThreadPool、newSingleThreadExecutor、newScheduledThreadPool；</p>
<p>手动创建体现在可以灵活设置线程池的各个参数，体现在代码中即ThreadPoolExecutor类构造器上各个实参的不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(var0, var0, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Executors</span>.FinalizableDelegatedExecutorService(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>()));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, <span class="number">2147483647</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(var0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                           <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                           <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                           TimeUnit unit,</span></span><br><span class="line"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                           ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;……&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池中的七大参数如下："><a href="#线程池中的七大参数如下：" class="headerlink" title="线程池中的七大参数如下："></a>线程池中的七大参数如下：</h3><p>（1）corePoolSize：线程池中的常驻核心线程数。</p>
<p>（2）maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值大于等于1。</p>
<p>（3）keepAliveTime：多余的空闲线程存活时间，当空间时间达到keepAliveTime值时，多余的线程会被销毁直到只剩下corePoolSize个线程为止。</p>
<p>（4）unit：keepAliveTime的单位。</p>
<p>（5）workQueue：任务队列，被提交但尚未被执行的任务。</p>
<p>（6）threadFactory：表示生成线程池中工作线程的线程工厂，用户创建新线程，一般用默认即可。</p>
<p>（7）handler：拒绝策略，表示当线程队列满了并且工作线程大于等于线程池的最大显示数(maxnumPoolSize)时如何来拒绝请求执行的runnable的策略。</p>
<p> 流程分析</p>
<ul>
<li>线程池中线程数小于corePoolSize时，新任务将创建一个新线程执行任务，不论此时线程池中存在空闲线程；</li>
<li>线程池中线程数达到corePoolSize时，新任务将被放入workQueue中，等待线程池中任务调度执行；</li>
<li>当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新任务会创建新线程执行任务；</li>
<li>当workQueue已满，且提交任务数超过maximumPoolSize，任务由RejectedExecutionHandler处理；</li>
<li>当线程池中线程数超过corePoolSize，且超过这部分的空闲时间达到keepAliveTime时，回收该线程；</li>
<li>如果设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize范围内的线程空闲时间达到keepAliveTime也将回收；</li>
</ul>
<p>一：corePoolSize 详细描述</p>
<p>（1）在创建了线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近视理解为今日当值线程。<br>（2）当线程池中的线程数目达到corePoolSize后，就会把到达的任务放入到缓存队列当中。</p>
<p>二：最大线程数（maximumPoolSize）:该参数定义了一个线程池中最多能容纳多少个线程。当一个任务提交到线程池中时，如果线程数量达到了核心线程数，并且任务队列已满，不能再向任务队列中添加任务时，这时会检查任务是否达到了最大线程数，如果未达到，则创建新线程，执行任务，否则，执行拒绝策略。可以通过源码来看一下。如下：可以看出，当调用submit（Runnable task）方法，将任务提交到线程池中时，会调用execute（）方法去执行任务，在该方法内，会进行核心线程数，任务队列的判断，最后决定是执行或者是拒绝。总结起来就是：最大线程数参数，是在已经达到核心线程池参数，并且任务队列已经满的情况下，才去判断该参数。</p>
<p>三：keepAliveTime 详细描述</p>
<p>只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用，直到线程中的线程数不大于corepoolSIze。</p>
<p>四：系统默认的拒绝策略有以下几种：</p>
<ul>
<li><ul>
<li>AbortPolicy：为线程池默认的拒绝策略，该策略直接抛异常处理。</li>
<li>DiscardPolicy：直接抛弃不处理。</li>
<li>DiscardOldestPolicy：丢弃队列中最老的任务。</li>
<li>CallerRunsPolicy：将任务分配给当前执行execute方法线程来处理。</li>
</ul>
</li>
</ul>
<p>线程池状态： Running， ShuttingDown， Termitnaed  </p>
<ul>
<li>Running - 线程池正在执行中。活动状态。  </li>
<li>ShuttingDown - 线程池正在关闭过程中。优雅关闭。一旦进入这个状态，线程池不再接收新的任务，处理所有已接收的任务，处理完毕后，关闭线程池。  </li>
<li>Terminated - 线程池已经关闭。</li>
</ul>
<h2 id="2-1-固定容量线程池FixedThreadPool"><a href="#2-1-固定容量线程池FixedThreadPool" class="headerlink" title="2.1 固定容量线程池FixedThreadPool"></a>2.1 固定容量线程池FixedThreadPool</h2><p>FixedThreadPool是固定容量线程池，创建线程池的时候容量固定，使用的是BlockingQueue<Runnable>作为任务的载体，线程池默认的容量上限是Integer.MAX_VALUE  </p>
<ul>
<li>特点：当任务数量大于线程池容量的时候，没有运行的任务保存在任务队列中，当线程有空闲的，自动从队列中取出任务执行  </li>
<li>使用场景： 大多数情况下，使用的线程池，首选推荐FixedThreadPool。OS系统和硬件是有线程支持上限。不能随意的无限制提供线程池。</li>
</ul>
<p><strong>下面是一个无返回值的小案例：</strong><br>案例中创建了一个线程池，容量为5，执行6个任务，分析调用shutdown方法后，分析任务的执行情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> * 固定容量线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_02_FixedThreadPool</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> </span><br><span class="line">				Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">			service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - test executor&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;初始状态：&quot;</span> + service);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;开始调用shutdown方法=====&quot;</span>);</span><br><span class="line">		service.shutdown();</span><br><span class="line">		<span class="comment">// 是否已经结束， 相当于回收了资源。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;是否terminated：&quot;</span> + service.isTerminated());</span><br><span class="line">		<span class="comment">// 是否已经关闭， 是否调用过shutdown方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;是否shutdown：&quot;</span> + service.isShutdown());</span><br><span class="line">		System.out.println(<span class="string">&quot;shutdown后的状态：&quot;</span> + service);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// service.shutdown();</span></span><br><span class="line">		System.out.println(<span class="string">&quot;2秒过后任务全部执行完====&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;是否terminated：&quot;</span> + service.isTerminated());</span><br><span class="line">		System.out.println(<span class="string">&quot;是否shutdown：&quot;</span> + service.isShutdown());</span><br><span class="line">		System.out.println(<span class="string">&quot;任务全部执行完过后状态：&quot;</span> + service);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzAzYTk3MTM1Mjc0ZWQ"><br>从图中可以分析出以下几个过程<br>在初始状态：五个执行线程，1个任务在等待队列，0个完成任务<br>↓<br>调用shutdown方法后：线程池未关闭（terminated为false），调用了shutdown（不再接收新任务），0个完成任务<br>↓<br>两秒后任务执行完毕：线程池已关闭（terminated为true），调用了shutdown（不再接收新任务），6个完成任务 </p>
<p><strong>下面是一个有返回值的小案例：</strong><br>案例中创建了一个线程池，容量为1，submit方法传了一个Callable,future通过get获取线程的返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> * 固定容量线程池（有返回值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_03_Future</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		Future&lt;String&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot; - test executor&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(<span class="string">&quot;线程是否结束: &quot;</span> + future.isDone()); <span class="comment">// 查看线程是否结束， 任务是否完成。 call方法是否执行结束</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;call方法的返回值: &quot;</span> + future.get()); <span class="comment">// 获取call方法的返回值。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;线程是否结束: &quot;</span> + future.isDone());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭线程池</span></span><br><span class="line">		service.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzAzYmIyMTMwZGMyN2Y"></p>
<h2 id="2-2-CachedThreadPool"><a href="#2-2-CachedThreadPool" class="headerlink" title="2.2 CachedThreadPool"></a>2.2 CachedThreadPool</h2><p>缓存的线程池, 容量不限（Integer.MAX_VALUE）,自动扩容<br>容量管理策略：如果线程池中的线程数量不满足任务执行，创建新的线程。每次有新任务无法即时处理的时候，都会创建新的线程。当线程池中的线程空闲时长达到一定的临界值（默认60秒），自动释放线程，这里通过Executors.newCachedThreadPool()方法得到的线程池无法修改空闲时间，具体原因见下图，但可以通过自定义线程池ThreadPoolExecutor修改，具体方法见2.5，这里就不解释了</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzAzZGIzZWM5MDhiZTM"><br>应用场景： 内部应用或测试应用。 </p>
<ul>
<li>内部应用，有条件的内部数据瞬间处理时应用，如：电信平台夜间执行数据整理（有把握在短时间内处理完所有工作，且对硬件和软件有足够的信心）。</li>
<li>测试应用，在测试的时候，尝试得到硬件或软件的最高负载量，用于提供FixedThreadPool容量的指导</li>
</ul>
<p>案例演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> * 无容量限制的线程池（最大容量默认为Integer.MAX_VALUE）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_05_CachedThreadPool</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">		</span><br><span class="line">		System.out.println(service);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">			service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - test executor&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(service);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">65</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(service);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-计划任务线程池ScheduledThreadPool"><a href="#2-3-计划任务线程池ScheduledThreadPool" class="headerlink" title="2.3 计划任务线程池ScheduledThreadPool"></a>2.3 计划任务线程池ScheduledThreadPool</h2><p>ScheduledThreadPool是计划任务线程池，可以根据计划自动执行任务的线程池，底层实现是一个DelayedWorkQueue，它的一个主要方法scheduleAtFixedRate<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzAzZTRiODk5ZTQ1N2M"><br>有以下几个参数：  </p>
<ul>
<li>command - 要执行的任务</li>
<li>initialDelay - 第一次任务执行的间隔。</li>
<li>period - 多次任务执行的间隔。</li>
<li>unit - 多次任务执行间隔的时间单位。</li>
</ul>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> * 计划任务线程池。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_07_ScheduledThreadPool</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">		System.out.println(service);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 定时完成任务。 scheduleAtFixedRate(Runnable, start_limit, limit, timeunit)</span></span><br><span class="line">		<span class="comment">// runnable - 要执行的任务。</span></span><br><span class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="number">0</span>, <span class="number">300</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-4-单一容量的线程池SingleThreadExecutor"><a href="#2-4-单一容量的线程池SingleThreadExecutor" class="headerlink" title="2.4 单一容量的线程池SingleThreadExecutor"></a>2.4 单一容量的线程池SingleThreadExecutor</h2><p>单一容量的线程池，用法和FixedThreadPool类似，但和newFixedThreadPool不一样的是newSingleThreadExecutor创建的线程池又被一个FinalizableDelegatedExecutorService包装了一下<br>总结一下SingleThreadExecutor：</p>
<ul>
<li>单线任务处理的线程池</li>
<li>shutdown方法必然会被调用</li>
<li>不具备ThreadPoolExecutor所有功能的线程池<br>具体可以看看这篇文章：<code>https://www.jianshu.com/p/2b7d853322bb</code></li>
</ul>
<h2 id="2-5-分支合并线程池ForkJoinPool"><a href="#2-5-分支合并线程池ForkJoinPool" class="headerlink" title="2.5 分支合并线程池ForkJoinPool"></a>2.5 分支合并线程池ForkJoinPool</h2><p>分支合并线程池（mapduce类似的设计思想），可以递归完成复杂任务，适合用于处理复杂任务<br>要求可分支合并的任务必须是ForkJoinTask类型的子类型<br>ForkJoinTask类型提供了两个抽象子类型：<br>RecursiveTask有返回结果的分支合并任务<br>RecursiveAction无返回结果的分支合并任务</p>
<p>案例：<br>这个案例做了一个以ForkJoinPool实现的数据累加，当计算数字区间大于MAX_SIZE&#x3D;50000时，开启新的线程任务的计算，最后合并统计结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> * 分支合并线程池。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_08_ForkJoinPool</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000000</span>];</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">500000</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">			numbers[i] = r.nextInt(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AddTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt;&#123; <span class="comment">// RecursiveAction</span></span><br><span class="line">		<span class="type">int</span> begin, end;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">AddTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.begin = begin;</span><br><span class="line">			<span class="built_in">this</span>.end = end;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">		<span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>((end - begin) &lt; MAX_SIZE)&#123;</span><br><span class="line">				<span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; end; i++)&#123;</span><br><span class="line">					sum += numbers[i];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// System.out.println(&quot;form &quot; + begin + &quot; to &quot; + end + &quot; sum is : &quot; + sum);</span></span><br><span class="line">				<span class="keyword">return</span> sum;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> begin + (end - begin)/<span class="number">2</span>;</span><br><span class="line">				<span class="type">AddTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(begin, middle);</span><br><span class="line">				<span class="type">AddTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(middle, end);</span><br><span class="line">				task1.fork();<span class="comment">// 就是用于开启新的任务的。 就是分支工作的。 就是开启一个新的线程任务。</span></span><br><span class="line">				task2.fork();</span><br><span class="line">				<span class="comment">// join - 合并。将任务的结果获取。 这是一个阻塞方法。一定会得到结果数据。</span></span><br><span class="line">				<span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, IOException &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">			result += numbers[i];</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(result);</span><br><span class="line">		</span><br><span class="line">		<span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">		<span class="type">AddTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(<span class="number">0</span>, numbers.length);</span><br><span class="line">		</span><br><span class="line">		Future&lt;Long&gt; future = pool.submit(task);</span><br><span class="line">		System.out.println(future.get());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：该任务分类四个线程任务进行计算，最后汇总</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzA0M2RlMTcxNDMxNjY"></p>
<h2 id="2-5-ThreadPoolExecutor"><a href="#2-5-ThreadPoolExecutor" class="headerlink" title="2.5 ThreadPoolExecutor"></a>2.5 ThreadPoolExecutor</h2><p>ThreadPoolExecutor线程池的底层实现，除ForkJoinPool外，其他常用线程池底层都是使用ThreadPoolExecutor实现的，其中有一个构造方法如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE4LzE2YzA0NGNhZDMwZWRkZGI"></p>
<ul>
<li>corePoolSize：核心容量，创建线程池的时候，默认有多少线程。也是线程池保持的最少线程数</li>
<li>maximumPoolSize： 最大容量，线程池最多有多少线程</li>
<li>keepAliveTime： 生命周期，0为永久。当线程空闲多久后，自动回收</li>
<li>unit: 生命周期单位，为生命周期提供单位，如：秒，毫秒</li>
<li>workQueue 任务队列，阻塞队列。注意，泛型必须是Runnable</li>
</ul>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> * 固定容量线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_09_ThreadPoolExecutor</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 模拟fixedThreadPool， 核心线程5个，最大容量5个，线程的生命周期无限。</span></span><br><span class="line">		<span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> </span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">						<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">			service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - test executor&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(service);</span><br><span class="line">		</span><br><span class="line">		service.shutdown();</span><br><span class="line">		System.out.println(service.isTerminated());</span><br><span class="line">		System.out.println(service.isShutdown());</span><br><span class="line">		System.out.println(service);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		service.shutdown();</span><br><span class="line">		System.out.println(service.isTerminated());</span><br><span class="line">		System.out.println(service.isShutdown());</span><br><span class="line">		System.out.println(service);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多精彩内容：<a href="https://mrxccc.github.io/">mrxccc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrxccc.github.io/posts/fcbd1efb.html" data-id="cm5kxt8ns001bkku4ckri9s3m" data-title="JUC-各种线程池汇总" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-spring常用注解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/4746834b.html" class="article-date">
  <time class="dt-published" datetime="2019-08-09T01:22:32.000Z" itemprop="datePublished">2019-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/4746834b.html">spring常用注解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>@[toc]</p>
<h1 id="1-常用注解及作用"><a href="#1-常用注解及作用" class="headerlink" title="1.常用注解及作用"></a>1.常用注解及作用</h1><h2 id="1-1-Configuration"><a href="#1-1-Configuration" class="headerlink" title="1.1 @Configuration"></a>1.1 @Configuration</h2><p>声明当前类是一个配置类（相当于一个Spring配置的xml文件）</p>
<h2 id="1-2-ComponentScan"><a href="#1-2-ComponentScan" class="headerlink" title="1.2 @ComponentScan"></a>1.2 @ComponentScan</h2><p>自动扫描指定包下所有使用@Service,@Component,@Controller,@Repository的类并注册<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(value=&quot;com.atguigu&quot;,includeFilters = &#123;</span><br><span class="line">		@Filter(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;),</span><br><span class="line">		@Filter(type=FilterType.ASSIGNABLE_TYPE,classes=&#123;BookService.class&#125;),</span><br><span class="line">		@Filter(type=FilterType.CUSTOM,classes=&#123;MyTypeFilter.class&#125;)</span><br><span class="line">			&#125;,useDefaultFilters = false)	</span><br><span class="line">//excludeFilters = Filter[] ：指定扫描的时候按照什么规则排除那些组件</span><br><span class="line">//includeFilters = Filter[] ：指定扫描的时候只需要包含哪些组件,</span><br><span class="line">需设置useDefaultFilters = false</span><br><span class="line">//FilterType.ANNOTATION：按照注解</span><br><span class="line">//FilterType.ASSIGNABLE_TYPE：按照给定的类型；</span><br><span class="line">//FilterType.ASPECTJ：使用ASPECTJ表达式</span><br><span class="line">//FilterType.REGEX：使用正则指定</span><br><span class="line">//FilterType.CUSTOM：使用自定义规则</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-3-ComponentScans"><a href="#1-3-ComponentScans" class="headerlink" title="1.3 @ComponentScans"></a>1.3 @ComponentScans</h2><p>可包含多个@ComponentScan<br>示例：@ComponentScans(value &#x3D; {@ComponentScan,@ComponentScan,@ComponentScan})</p>
<h2 id="1-4-Lazy"><a href="#1-4-Lazy" class="headerlink" title="1.4 @Lazy"></a>1.4 @Lazy</h2><p>单实例bean：默认在容器启动的时候创建对象；<br>懒加载：容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化；  </p>
<h2 id="1-5-Conditional-Condition"><a href="#1-5-Conditional-Condition" class="headerlink" title="1.5 @Conditional({Condition})"></a>1.5 @Conditional({Condition})</h2><p>示例：@Conditional({WindowsCondition.class})，WindowsCondition是实现了Condition接口的类<br>按照一定的条件进行判断，满足条件给容器中注册bean，可定义在类名或者方法名上</p>
<h2 id="1-6-注入组件"><a href="#1-6-注入组件" class="headerlink" title="1.6 注入组件"></a>1.6 注入组件</h2><p>容器中注入组件的方式<br>1 @Bean:导入第三方的类或包的组件<br>2.ComponentScan：包扫描+组件的标注注解<br>3.@Import<br>4.使用Spring提供的FactoryBean(工厂Bean)进行注册 </p>
<h3 id="1-6-1-Import-快速导入组件"><a href="#1-6-1-Import-快速导入组件" class="headerlink" title="1.6.1 @Import()快速导入组件"></a>1.6.1 @Import()快速导入组件</h3><p>可导入单个组件或者多个组件，id默认为全类名<br>示例：@Import(value&#x3D;{Dog.class,Cat.class,MyImportSelector.class,MyImportBeanDefinitionRegistrar.class})  </p>
<h3 id="1-6-2-使用ImportSelector自定义需要导入的组件"><a href="#1-6-2-使用ImportSelector自定义需要导入的组件" class="headerlink" title="1.6.2.使用ImportSelector自定义需要导入的组件"></a>1.6.2.使用ImportSelector自定义需要导入的组件</h3><p>ImportSelector是一个接口，接口定义的方法为一个包含组件全类名的字符串数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//自定义逻辑返回需要导入的组件</span><br><span class="line">public class MyImportSelector implements ImportSelector &#123;</span><br><span class="line"></span><br><span class="line">	//返回值，就是到导入到容器中的组件全类名</span><br><span class="line">	//AnnotationMetadata:当前标注@Import注解的类的所有注解信息</span><br><span class="line">	@Override</span><br><span class="line">	public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		//importingClassMetadata</span><br><span class="line">		//方法不要返回null值，否则会报空指针异常</span><br><span class="line">		return new String[]&#123;&quot;com.bernard.bean.Blue&quot;,&quot;com.bernard.bean.Yellow&quot;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-3-使用ImportBeamDefinitionRegistrar返回自定义组件"><a href="#1-6-3-使用ImportBeamDefinitionRegistrar返回自定义组件" class="headerlink" title="1.6.3.使用ImportBeamDefinitionRegistrar返回自定义组件"></a>1.6.3.使用ImportBeamDefinitionRegistrar返回自定义组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * AnnotationMetadata：当前类的注解信息</span><br><span class="line">	 * BeanDefinitionRegistry:BeanDefinition注册类；</span><br><span class="line">	 * 把所有需要添加到容器中的bean；</span><br><span class="line">	 * 调用BeanDefinitionRegistry.registerBeanDefinition手工注册进来</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		</span><br><span class="line">		boolean definition = registry.containsBeanDefinition(&quot;com.atguigu.bean.Red&quot;);</span><br><span class="line">		boolean definition2 = registry.containsBeanDefinition(&quot;com.atguigu.bean.Blue&quot;);</span><br><span class="line">		if(definition &amp;&amp; definition2)&#123;</span><br><span class="line">			//指定Bean定义信息；（Bean的类型，Bean。。。）</span><br><span class="line">			RootBeanDefinition beanDefinition = new RootBeanDefinition(RainBow.class);</span><br><span class="line">			//注册一个Bean，指定bean名</span><br><span class="line">			registry.registerBeanDefinition(&quot;rainBow&quot;, beanDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong><br>打印出所有注册到容器的bean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyImportTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test01()&#123;</span><br><span class="line">        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(MyImportConfig.class);</span><br><span class="line"></span><br><span class="line">        String[] beanDefinitionNames = annotationConfigApplicationContext.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; beanDefinitionNames.length; i++) &#123;</span><br><span class="line">            String beanDefinitionName = beanDefinitionNames[i];</span><br><span class="line">            System.out.println(beanDefinitionName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-4-使用Spring提供的-FactoryBean（工厂Bean）"><a href="#1-6-4-使用Spring提供的-FactoryBean（工厂Bean）" class="headerlink" title="1.6.4.使用Spring提供的 FactoryBean（工厂Bean）;"></a>1.6.4.使用Spring提供的 FactoryBean（工厂Bean）;</h3><p>1）、默认获取到的是工厂bean调用getObject创建的对象<br>2）、要获取工厂Bean本身，我们需要给id前面加一个&amp;,如：“&amp;colorFactoryBean”	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//创建一个Spring定义的FactoryBean</span><br><span class="line">public class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123;</span><br><span class="line"></span><br><span class="line">	//返回一个Color对象，这个对象会添加到容器中</span><br><span class="line">	@Override</span><br><span class="line">	public Color getObject() throws Exception &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		System.out.println(&quot;ColorFactoryBean...getObject...&quot;);</span><br><span class="line">		return new Color();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return Color.class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//是单例？</span><br><span class="line">	//true：这个bean是单实例，在容器中保存一份</span><br><span class="line">	//false：多实例，每次获取都会创建一个新的bean；</span><br><span class="line">	@Override</span><br><span class="line">	public boolean isSingleton() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注册示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ColorFactoryBean colorFactoryBean()&#123;</span><br><span class="line">	return new ColorFactoryBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//工厂Bean获取的是调用getObject创建的对象</span><br><span class="line">Object bean2 = applicationContext.getBean(&quot;colorFactoryBean&quot;);//获取getObject返回的bean</span><br><span class="line">Object bean4 = applicationContext.getBean(&quot;&amp;colorFactoryBean&quot;);//获取工厂bean本身</span><br></pre></td></tr></table></figure>

<h2 id="1-7-Value"><a href="#1-7-Value" class="headerlink" title="1.7 @Value"></a>1.7 @Value</h2><p>使用@Value可以为属性字段赋值<br>1、基本数值<br>2、可以写SpEL； #{}<br>3、可以写${}；取出配置文件【properties】中的值（在运行环境变量里面的值）  </p>
<p><strong>配置类</strong><br>使用@PropertySource读取外部配置文件中的k&#x2F;v保存到运行的环境变量中;<br>加载完外部的配置文件以后使用${}取出配置文件的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(value=&#123;&quot;classpath:/person.properties&quot;&#125;)</span><br><span class="line">@Configuration</span><br><span class="line">public class MainConfigOfPropertyValues &#123;</span><br><span class="line">	</span><br><span class="line">	@Bean</span><br><span class="line">	public Person person()&#123;</span><br><span class="line">		return new Person();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>bean</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">	@Value(&quot;张三&quot;)</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;#&#123;20-2&#125;&quot;)</span><br><span class="line">	private Integer age;</span><br><span class="line">	</span><br><span class="line">	@Value(&quot;$&#123;person.nickName&#125;&quot;)</span><br><span class="line">	private String nickName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-8-Autowired、-Resource、-Primary"><a href="#1-8-Autowired、-Resource、-Primary" class="headerlink" title="1.8 @Autowired、@Resource、@Primary"></a>1.8 @Autowired、@Resource、@Primary</h2><ul>
<li>默认优先按照类型去容器中找对应的组件:applicationContext.getBean(BookDao.class);找到就赋值</li>
<li>如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找applicationContext.getBean(“bookDao”)</li>
<li>自动装配默认一定要将属性赋值好，没有就会报错，如果注入容器中不存在的bean,可以使用@Autowired(required&#x3D;false);</li>
<li>@Qualifier(“组件id”)：使用@Qualifier指定需要装配的组件的id，而不是使用属性名</li>
<li>@Primary：让Spring进行自动装配的时候，默认使用首选的bean（使用该方式，注入组件时就不能使用@Qualifier了）；</li>
<li>@Inject：需要导入javax.inject的包，和Autowired的功能一样。没有required&#x3D;false的功能；</li>
<li>@Resource可以和@Autowired一样实现自动装配功能；默认是按照组件名称进行装配的；没有能支持@Primary和@Autowired（reqiured&#x3D;false）功能;</li>
</ul>
<p>@Autowired:构造器，参数，方法，属性；都是从容器中获取参数组件的值</p>
<ul>
<li>如果@Autowired标注在方法&#x2F;或参数位置上，Spring创建当前对象的时候，就会调用该方法完成赋值，方法使用的参数，会从ioc容器中获取，默认不写@Autowired效果是一样的,都能自动装配    </li>
<li>如果@Autowired标注在构造器上：如果组件只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以自动从容器中获取</li>
<li>如果@Bean标注的的方法创建对象时，方法参数的值从容器中获取</li>
</ul>
<p><strong>补充：<br>@Autowired:Spring定义的；<br>@Resource、@Inject都是java规范</strong></p>
<h2 id="1-9-Profile"><a href="#1-9-Profile" class="headerlink" title="1.9 @Profile"></a>1.9 @Profile</h2><p>指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件</p>
<ul>
<li>1）、加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中。默认是default环境</li>
<li>2）、写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效</li>
<li>3）、没有标注环境标识的bean,在任何环境下都是加载的；<br><strong>java配置MainConfigOfProfile.java</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&quot;classpath:/dbconfig.properties&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class MainConfigOfProfile implements EmbeddedValueResolverAware&#123;</span><br><span class="line">	</span><br><span class="line">	@Value(&quot;$&#123;db.user&#125;&quot;)</span><br><span class="line">	private String user;</span><br><span class="line">	</span><br><span class="line">	private StringValueResolver valueResolver;</span><br><span class="line">	</span><br><span class="line">	private String  driverClass;</span><br><span class="line">	</span><br><span class="line">	@Bean</span><br><span class="line">	public Yellow yellow()&#123;</span><br><span class="line">		return new Yellow();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Profile(&quot;test&quot;)</span><br><span class="line">	@Bean(&quot;testDataSource&quot;)</span><br><span class="line">	public DataSource dataSourceTest(@Value(&quot;$&#123;db.password&#125;&quot;)String pwd) throws Exception&#123;</span><br><span class="line">		ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line">		dataSource.setUser(user);</span><br><span class="line">		dataSource.setPassword(pwd);</span><br><span class="line">		dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);</span><br><span class="line">		dataSource.setDriverClass(driverClass);</span><br><span class="line">		return dataSource;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Profile(&quot;dev&quot;)</span><br><span class="line">	@Bean(&quot;devDataSource&quot;)</span><br><span class="line">	public DataSource dataSourceDev(@Value(&quot;$&#123;db.password&#125;&quot;)String pwd) throws Exception&#123;</span><br><span class="line">		ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line">		dataSource.setUser(user);</span><br><span class="line">		dataSource.setPassword(pwd);</span><br><span class="line">		dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/ssm_crud&quot;);</span><br><span class="line">		dataSource.setDriverClass(driverClass);</span><br><span class="line">		return dataSource;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Profile(&quot;prod&quot;)</span><br><span class="line">	@Bean(&quot;prodDataSource&quot;)</span><br><span class="line">	public DataSource dataSourceProd(@Value(&quot;$&#123;db.password&#125;&quot;)String pwd) throws Exception&#123;</span><br><span class="line">		ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line">		dataSource.setUser(user);</span><br><span class="line">		dataSource.setPassword(pwd);</span><br><span class="line">		dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/scw_0515&quot;);</span><br><span class="line">		</span><br><span class="line">		dataSource.setDriverClass(driverClass);</span><br><span class="line">		return dataSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void setEmbeddedValueResolver(StringValueResolver resolver) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		this.valueResolver = resolver;</span><br><span class="line">		driverClass = valueResolver.resolveStringValue(&quot;$&#123;db.driverClass&#125;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
激活方式：</li>
<li>1、使用命令行动态参数: 在虚拟机参数位置加载 -Dspring.profiles.active&#x3D;test</li>
<li>2、java代码的方式激活某种环境,分为四步<ul>
<li>1)、创建一个applicationContext</li>
<li>2)、设置需要激活的环境</li>
<li>3)、注册主配置类</li>
<li>4)、启动刷新容器</li>
</ul>
</li>
</ul>
<p><strong>激活测试代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void test01()&#123;</span><br><span class="line">	AnnotationConfigApplicationContext applicationContext =</span><br><span class="line">			new AnnotationConfigApplicationContext();</span><br><span class="line">	//1、创建一个applicationContext</span><br><span class="line">	//2、设置需要激活的环境</span><br><span class="line">	applicationContext.getEnvironment().setActiveProfiles(&quot;dev&quot;);</span><br><span class="line">	//3、注册主配置类</span><br><span class="line">	applicationContext.register(MainConfigOfProfile.class);</span><br><span class="line">	//4、启动刷新容器</span><br><span class="line">	applicationContext.refresh();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	String[] namesForType = applicationContext.getBeanNamesForType(DataSource.class);</span><br><span class="line">	for (String string : namesForType) &#123;</span><br><span class="line">		System.out.println(string);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Yellow bean = applicationContext.getBean(Yellow.class);</span><br><span class="line">	System.out.println(bean);</span><br><span class="line">	applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-10-Scope"><a href="#1-10-Scope" class="headerlink" title="1.10 @Scope"></a>1.10 @Scope</h2><p>在注册bean时，spring默认是单实例的，即scope&#x3D;”singleton”，除此之外，常见的scope还有prototype、request、session作用域</p>
<ul>
<li>prototype：多实例的：ioc容器启动并不会去调用方法创建对象放在容器中。</li>
<li>request：同一次请求创建一个实例</li>
<li>session：同一个session创建一个实例</li>
</ul>
<p>更多精彩内容：<a href="https://mrxccc.github.io/">mrxccc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrxccc.github.io/posts/4746834b.html" data-id="cm5kxt8o7002mkku43yxf872s" data-title="spring常用注解" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ReentrantLock与synchronized对比" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/ecbf6ed0.html" class="article-date">
  <time class="dt-published" datetime="2019-08-09T01:18:33.000Z" itemprop="datePublished">2019-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/ecbf6ed0.html">ReentrantLock与synchronized对比</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-ReentrantLock与synchronized对比"><a href="#1-ReentrantLock与synchronized对比" class="headerlink" title="1 ReentrantLock与synchronized对比"></a>1 ReentrantLock与synchronized对比</h1><p>ReentrantLock与synchronized都是为了同步加锁,但ReentrantLock相对效率比synchronized高，量级较轻。<br>synchronized在JDK1.5版本开始，尝试优化。到JDK1.7版本后，优化效率已经非常好了。在绝对效率上，不比reentrantLock差多少。使用ReentrantLock，<strong>必须手工释放锁标记</strong>。一般都是在finally代码块中定义释放锁标记的unlock方法。</p>
<h1 id="2-示例用法"><a href="#2-示例用法" class="headerlink" title="2.示例用法"></a>2.示例用法</h1><h2 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h2><p>lock()与unlock()就像synchronized同步代码块的开始与结束，使用ReentrantLocky一定要记得unlock()解锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.bernardlowe.concurrent.t03;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Test_01 &#123;</span><br><span class="line">	Lock lock = new ReentrantLock();</span><br><span class="line">	</span><br><span class="line">	void m1()&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			lock.lock(); // 加锁</span><br><span class="line">			for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(1);</span><br><span class="line">				System.out.println(&quot;m1() method &quot; + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;catch(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			lock.unlock(); // 解锁</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void m2()&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		System.out.println(&quot;m2() method&quot;);</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final Test_01 t = new Test_01();</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				t.m1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		try &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(1);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				t.m2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-尝试锁"><a href="#2-2-尝试锁" class="headerlink" title="2.2 尝试锁"></a>2.2 尝试锁</h2><p>尝试锁，顾名思义是尝试获取锁标记trylock()，有两种方式  </p>
<ul>
<li><p>无参尝试锁:会根据是否能获取当前锁标记返回对应值</p>
<blockquote>
<p>boolean tryLock();  </p>
</blockquote>
</li>
<li><p>有参阻塞尝试锁, 阻塞尝试锁，阻塞参数代表等待超时时间。</p>
<blockquote>
<p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 尝试锁</span><br><span class="line"> */</span><br><span class="line">package com.bernardlowe.concurrent.t03;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Test_02 &#123;</span><br><span class="line">	Lock lock = new ReentrantLock();</span><br><span class="line">	</span><br><span class="line">	void m1()&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(1);</span><br><span class="line">				System.out.println(&quot;m1() method &quot; + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;catch(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void m2()&#123;</span><br><span class="line">		boolean isLocked = false;</span><br><span class="line">		try&#123;</span><br><span class="line">			// 尝试锁， 如果有锁，无法获取锁标记，返回false。</span><br><span class="line">			// 如果获取锁标记，返回true</span><br><span class="line">			// isLocked = lock.tryLock();</span><br><span class="line">			</span><br><span class="line">			// 阻塞尝试锁，阻塞参数代表的时长，尝试获取锁标记。</span><br><span class="line">			// 如果超时，不等待。直接返回。</span><br><span class="line">			isLocked = lock.tryLock(5, TimeUnit.SECONDS); </span><br><span class="line">			</span><br><span class="line">			if(isLocked)&#123;</span><br><span class="line">				System.out.println(&quot;m2() method synchronized&quot;);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				System.out.println(&quot;m2() method unsynchronized&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;catch(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			if(isLocked)&#123;</span><br><span class="line">				// 尝试锁在解除锁标记的时候，一定要判断是否获取到锁标记。</span><br><span class="line">				// 如果当前线程没有获取到锁标记，会抛出异常。</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final Test_02 t = new Test_02();</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				t.m1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		try &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(1);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				t.m2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-可打断"><a href="#2-3-可打断" class="headerlink" title="2.3 可打断"></a>2.3 可打断</h2><p>先解释下线程的几种状态：<br>阻塞状态： 包括普通阻塞，等待队列，锁池队列。<br>普通阻塞： sleep(10000)， 可以被打断。调用thread.interrupt()方法，可以打断阻塞状态，抛出异常。<br>等待队列： wait()方法被调用，也是一种阻塞状态，只能由notify唤醒。无法打断<br>锁池队列： 无法获取锁标记。不是所有的锁池队列都可被打断</p>
<ul>
<li>使用ReentrantLock的lock方法，获取锁标记的时候，如果需要阻塞等待锁标记，无法被打断。</li>
<li>使用ReentrantLock的lockInterruptibly方法，获取锁标记的时候，如果需要阻塞等待，可以被打断。</li>
</ul>
<p>示例代码<br>主线程启动了两个线程t1,t2，t1调用m1(),t2调用m2()<br>当主线程调用interrupt()方法，可以打断t2线程的阻塞等待锁，抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.bernardlowe.concurrent.t03;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Test_03 &#123;</span><br><span class="line">	Lock lock = new ReentrantLock();</span><br><span class="line">	</span><br><span class="line">	void m1()&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(1);</span><br><span class="line">				System.out.println(&quot;m1() method &quot; + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;catch(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void m2()&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			lock.lockInterruptibly(); // 可尝试打断，阻塞等待锁。可以被其他的线程打断阻塞状态</span><br><span class="line">			System.out.println(&quot;m2() method&quot;);</span><br><span class="line">		&#125;catch(InterruptedException e)&#123;</span><br><span class="line">			System.out.println(&quot;m2() method interrupted&quot;);</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			try&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;catch(Exception e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final Test_03 t = new Test_03();</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				t.m1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		try &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(1);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				t.m2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t2.start();</span><br><span class="line">		try &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(1);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		t2.interrupt();// 打断线程休眠。非正常结束阻塞状态的线程，都会抛出异常。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如图<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE2LzE2YmZhZTYwNTBkZTNmNDc"></p>
<h2 id="2-4-公平锁"><a href="#2-4-公平锁" class="headerlink" title="2.4 公平锁"></a>2.4 公平锁</h2><p>操作系统cpu，为了保证效率，线程的执行机制是竞争机制，或者说是随机机制，是不公平的，使用ReentrantLock实现公平锁，是非常简单的，只需要在创建ReentrantLock的时候传一个参数<code>ReentrantLock lock = new ReentrantLock(true);</code><br>示例代码：<br>TestReentrantlock是公平锁<br>TestSync是非公平锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 公平锁</span><br><span class="line"> */</span><br><span class="line">package com.bernardlowe.concurrent.t03;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Test_04 &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TestReentrantlock t = new TestReentrantlock();</span><br><span class="line">		//TestSync t = new TestSync();</span><br><span class="line">		Thread t1 = new Thread(t);</span><br><span class="line">		Thread t2 = new Thread(t);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestReentrantlock extends Thread&#123;</span><br><span class="line">	// 定义一个公平锁</span><br><span class="line">	private static ReentrantLock lock = new ReentrantLock(true);</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			try&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + &quot; get lock&quot;);</span><br><span class="line">			&#125;finally&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestSync extends Thread&#123;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">			synchronized (this) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + &quot; get lock in TestSync&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>公平锁结果：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE2LzE2YmZhZWRkNzI4ZGVmOGQ"></p>
<p>非公平锁结果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE2LzE2YmZhZWU1MGVmNDVlZDE"></p>
<p>更多精彩内容：<a href="https://mrxccc.github.io/">mrxccc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrxccc.github.io/posts/ecbf6ed0.html" data-id="cm5kxt8o10021kku4gdjmedvc" data-title="ReentrantLock与synchronized对比" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JAVA案例分析内存可见性与原子性操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/164dc324.html" class="article-date">
  <time class="dt-published" datetime="2019-08-09T01:17:38.000Z" itemprop="datePublished">2019-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/164dc324.html">JAVA案例分析内存可见性与原子性操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-案例之变量内存可见性"><a href="#1-案例之变量内存可见性" class="headerlink" title="1 案例之变量内存可见性"></a>1 案例之变量内存可见性</h1><p><strong>代码解析：新起一个子线程执行m()方法，1秒后主线程将b置为false，子线程是否会停止执行死循环while(b){},打印“end”</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_09</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(b)&#123;&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Test_09</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_09</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				t.m();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		t.b = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**结果：1秒钟过后并不会停止执行死循环while(b){},打印“end”  **<br>这时候，如果将boolean b &#x3D; true;这段代码前加一个volatile关键字<br>即<code>volatile boolean b = true;</code>，就会达到预想中的效果  </p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE2LzE2YmY5NmExNjc4YzE5Njk"><br><strong>思考：为什么加上这个关键字，其他线程就会读取到已经改变的变量的值了？</strong>  </p>
<p>是因为在CPU计算过程中，会将计算过程需要的数据加载到<strong>CPU计算缓存</strong>中，当CPU计算中断时，有可能刷新缓存，重新读取内存中的数据。在线程运行的过程中，如果某变量被其他线程修改，可能造成数据不一致的情况，从而导致结果错误。<br>而volatile修饰的变量是线程可见的，当JVM解释volatile修饰的变量时，会通知CPU，在计算过程中，每次使用变量参与计算时，都会检查内存中的数据是否发生变化，而不是一直使用CPU缓存中的数据，可以保证计算结果的正确。</p>
<p>但是这样还有一个问题，volatile只能保证可见性，不能保证原子性</p>
<h1 id="2-案例之变量的原子性"><a href="#2-案例之变量的原子性" class="headerlink" title="2 案例之变量的原子性"></a>2 案例之变量的原子性</h1><p>下面再看一个示例：<br><strong>预期结果：起10个线程，每个线程都对count增加10000，预期结果为count&#x3D;100000</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_10</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Test_10</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_10</span>();</span><br><span class="line">		List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					t.m();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Thread thread : threads)&#123;</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Thread thread : threads)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				thread.join();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(t.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但结果并不是</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE2LzE2YmY5NzNlN2VjNGQ1OWU"><br><strong>原因是volatile只是通知底层计算时，CPU检查内存数据，而不是让一个变量在多个线程中同步。</strong>  </p>
<p>这时候可以给m()方法增加一个synchronized关键字，可以达到预期的效果，即<code>synchronized void m()</code></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE2LzE2YmY5NzdiYzFkODVhYjY"></p>
<p>还有另一种方法可以保证原子性，在上面代码将count声明为AtomicInteger原子操作，结果仍然是100000</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中的每个方法都是原子操作。可以保证线程安全。</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">		count.incrementAndGet();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不仅仅可声明Integer类型，java.util.concurrent.atomic包里面还有其他类型的</p>
<p>更多精彩内容：<a href="https://mrxccc.github.io/">mrxccc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrxccc.github.io/posts/164dc324.html" data-id="cm5kxt8np0014kku47x7ic6i3" data-title="JAVA案例分析内存可见性与原子性操作" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-synchronized关键字" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/ed378e14.html" class="article-date">
  <time class="dt-published" datetime="2019-08-08T10:24:43.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/posts/ed378e14.html">synchronized关键字</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-为什么要使用synchronized？"><a href="#1-为什么要使用synchronized？" class="headerlink" title="1.为什么要使用synchronized？"></a>1.为什么要使用synchronized？</h1><p>在并发编程中存在线程安全问题，主要原因有：<br>1.存在共享数据<br>2.多线程共同操作共享数据。关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性）</p>
<h1 id="2-synchronized锁什么，加锁的目的是什么？"><a href="#2-synchronized锁什么，加锁的目的是什么？" class="headerlink" title="2.synchronized锁什么，加锁的目的是什么？"></a>2.synchronized锁什么，加锁的目的是什么？</h1><p>synchronized锁的是对象，锁的的对象可能是this、临界资源对象、class类对象<br>加锁的目的是保证操作的原子性</p>
<h1 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h1><h2 id="3-1锁this和临界资源对象"><a href="#3-1锁this和临界资源对象" class="headerlink" title="3.1锁this和临界资源对象"></a>3.1锁this和临界资源对象</h2><p>本例中：  </p>
<ul>
<li>testSync1是synchronized代码块，锁的是object，临界资源对象</li>
<li>testSync2和testSync3都是锁的是当前对象this<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 锁对象。synchronized(this)和synchronized方法都是锁当前对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_01</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.synchronized代码块，锁的是object，临界资源对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSync1</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() </span><br><span class="line">					+ <span class="string">&quot; count = &quot;</span> + count++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.synchronized代码块，锁的是当前对象this</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSync2</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() </span><br><span class="line">					+ <span class="string">&quot; count = &quot;</span> + count++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.synchronized代码，锁的也是this</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testSync3</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() </span><br><span class="line">				+ <span class="string">&quot; count = &quot;</span> + count++);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Test_01</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_01</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				t.testSync3();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				t.testSync3();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-2锁class类对象"><a href="#3-2锁class类对象" class="headerlink" title="3.2锁class类对象"></a>3.2锁class类对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 同步方法 - static</span></span><br><span class="line"><span class="comment"> * 静态同步方法，锁的是当前类型的类对象。在本代码中就是Test_02.class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_02</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testSync4</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() </span><br><span class="line">				+ <span class="string">&quot; staticCount = &quot;</span> + staticCount++);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSync5</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(Test_02.class)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() </span><br><span class="line">					+ <span class="string">&quot; staticCount = &quot;</span> + staticCount++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-3-什么时候锁临界资源，什么时候锁当前对象？"><a href="#3-3-什么时候锁临界资源，什么时候锁当前对象？" class="headerlink" title="3.3 什么时候锁临界资源，什么时候锁当前对象？"></a>3.3 什么时候锁临界资源，什么时候锁当前对象？</h2><p>如果在加锁的时候需要对当前对象的访问限定，建议锁临界资源（即锁一个临界资源），如果对当前锁级别比较高的话，就锁当前对象。建议都以同步代码块的方式进行开发，这样可以避免锁的范围太高</p>
<p><strong>同步方法和非同步方法</strong><br><strong>提问:同步方法是否影响其他线程调用非同步方法，或调用其他锁资源的同步方法？</strong></p>
<p>代码示例<br>m1是非同步方法，m2是同步方法，m3同步代码块，锁的临界资源，这段代码的目的是为了证明在调用同步方法m1时，m2,m3是否能够执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 同步方法 - 同步方法和非同步方法的调用</span></span><br><span class="line"><span class="comment"> * 同步方法只影响锁定同一个锁对象的同步方法。不影响其他线程调用非同步方法，或调用其他锁资源的同步方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_04</span> &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123; <span class="comment">// 重量级的访问操作。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;public synchronized void m1() start&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;public synchronized void m1() end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(o)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;public void m3() start&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;public void m3() end&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;public void m2() start&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;public void m2() end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">MyThread01</span><span class="params">(<span class="type">int</span> i, Test_04 t)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.i = i;</span><br><span class="line">			<span class="built_in">this</span>.t = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> i ;</span><br><span class="line">		Test_04 t;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">				t.m1();</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				t.m2();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				t.m3();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Test_04</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_04</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread01</span>(<span class="number">0</span>, t)).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread01</span>(<span class="number">1</span>, t)).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread01</span>(-<span class="number">1</span>, t)).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE1LzE2YmYzOWFlMjBmMTI1YmE"><br>可以看出，在执行同步方法m1时，m2，m3不受影响，依然可以执行<br><strong>结论：同步方法只影响锁定同一个锁对象的同步方法。不影响其他线程调用非同步方法，或调用其他锁资源的同步方法。</strong><br>但有一点需要注意，尽量在商业开发中避免同步方法。使用同步代码块。 细粒度解决同步问题。</p>
<h2 id="3-3-重入锁"><a href="#3-3-重入锁" class="headerlink" title="3.3 重入锁"></a>3.3 重入锁</h2><p>这里重入锁分为两类：</p>
<ul>
<li>1.在同步方法里面调用其他同步方法</li>
<li>2.子类同步方法覆盖父类同步方法</li>
</ul>
<p>下面来看第一种：在同步方法里面调用其他同步方法<br><strong>思考：调用m1()方法，m2()方法是否会执行？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *synchronized关键字</span></span><br><span class="line"><span class="comment"> *同步方法 - 调用其他同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_06</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123; <span class="comment">// 锁this</span></span><br><span class="line">		System.out.println(<span class="string">&quot;m1 start&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		m2();</span><br><span class="line">		System.out.println(<span class="string">&quot;m1 end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123; <span class="comment">// 锁this</span></span><br><span class="line">		System.out.println(<span class="string">&quot;m2 start&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;m2 end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Test_06</span>().m1();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE1LzE2YmY0MWU1YTRhZTRiMDI"><br><strong>结果：在m1()方法调用时，m2()方法依然可执行。多次调用同步代码，锁定同一个锁对象，是可重入的</strong></p>
<p>第二种情况：子类同步方法覆盖父类同步方法<br><strong>思考：子类同步方法m()中,调用父类同步方法m()，是否可重入？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 同步方法 - 继承</span></span><br><span class="line"><span class="comment"> * 子类同步方法覆盖父类同步方法。可以指定调用父类的同步方法。</span></span><br><span class="line"><span class="comment"> * 相当于锁的重入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_07</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Super Class m start&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;Super Class m end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Sub_Test_07</span>().m();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Test_07</span> <span class="keyword">extends</span> <span class="title class_">Test_07</span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Sub Class m start&quot;</span>);</span><br><span class="line">		<span class="built_in">super</span>.m();</span><br><span class="line">		System.out.println(<span class="string">&quot;Sub Class m end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE1LzE2YmY0MjhlNGY3N2Q1OTE"><br><strong>结果：子类同步方法m()中,调用了父类同步方法m()，可以重入</strong></p>
<h2 id="3-4-锁与异常"><a href="#3-4-锁与异常" class="headerlink" title="3.4 锁与异常"></a>3.4 锁与异常</h2><p><strong>思考：当同步方法或同步代码块中发生异常，是否会影响其他线程的执行？</strong><br>下面来看一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 同步方法 - 锁与异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_08</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - start&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当i==5时会抛出异常</span></span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">				i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Test_08</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_08</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				t.m();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				t.m();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码中先运行了两个线程t1、t2，当其中一个线程发生异常时，另外一个线程是否能继续执行<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE2LzE2YmY4OTFjZTc1YjUyMDI"><br><strong>结果：当同步方法中发生异常的时候，自动释放锁资源。不会影响其他线程的执行。</strong>  </p>
<p><strong>思考： 同步业务逻辑中，如果发生异常如何处理？</strong><br>比如上面会发生异常的代码中，可以这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-锁对象变更问题"><a href="#3-5-锁对象变更问题" class="headerlink" title="3.5 锁对象变更问题"></a>3.5 锁对象变更问题</h2><p>代码示例：8<br><strong>思考：当一个线程执行同步方法时，另一个线程修改了锁对象，是否还能执行同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 锁对象变更问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_13</span> &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">		<span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + o);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Test_13</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_13</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				t.m();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				t.m();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">		t.o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzE2LzE2YmY5OWZkZjkzYzYyYTE"><br>结论：可以看出，其他线程依然可以执行同步方法<br>因为同步代码一旦加锁后，那么会有一个临时的锁引用执行锁对象，和真实的引用无直接关联。在锁未释放之前，修改锁对象引用，不会影响同步代码的执行。</p>
<p>注意：不要使用静态常量作为锁对象<br>如下代码,<strong>因为String常量池的问题，s1,s1是同一个对象，所以m1,m2方法锁的是也同一个对象</strong>，m1同步方法被执行后，m2方法不会被执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 常量问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.bernardlowe.concurrent.t01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_14</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="comment">// String s2 = new String(&quot;hello&quot;); // new关键字，一定是在堆中创建一个新的对象。</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;m1()&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;m2()&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Test_14</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test_14</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				t.m1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				t.m2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多精彩内容：<a href="https://mrxccc.github.io/">mrxccc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrxccc.github.io/posts/ed378e14.html" data-id="cm5kxt8o8002pkku46dyohr3t" data-title="synchronized关键字" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IC/">IC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/">Java8新特性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sonarquber/">Sonarquber</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/dfinity/">dfinity</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gitlab-ci/">gitlab-ci</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%8C%96%E5%88%B0%E4%BA%91%E5%8E%9F%E7%94%9F/">从服务化到云原生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A1%A8%E6%A0%BC%E5%A4%84%E7%90%86/">表格处理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IC/" rel="tag">IC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/POI/" rel="tag">POI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dfinity/" rel="tag">dfinity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/easyexcel/" rel="tag">easyexcel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E9%9D%A2/" rel="tag">知识面</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A8%E6%A0%BC%E5%A4%84%E7%90%86/" rel="tag">表格处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/IC/" style="font-size: 20px;">IC</a> <a href="/tags/POI/" style="font-size: 13.33px;">POI</a> <a href="/tags/dfinity/" style="font-size: 10px;">dfinity</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/easyexcel/" style="font-size: 10px;">easyexcel</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 13.33px;">区块链</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E9%9D%A2/" style="font-size: 10px;">知识面</a> <a href="/tags/%E8%A1%A8%E6%A0%BC%E5%A4%84%E7%90%86/" style="font-size: 13.33px;">表格处理</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 16.67px;">设计模式</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 10px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/undefined.html">solidity语言特性之数据类型</a>
          </li>
        
          <li>
            <a href="/posts/66a907b1.html">Gitlab-CICD最简单明了的入门教程</a>
          </li>
        
          <li>
            <a href="/posts/f73eb048.html">设计模式-拦截过滤器</a>
          </li>
        
          <li>
            <a href="/posts/fc25c4a4.html">IC中的账户及相关操作</a>
          </li>
        
          <li>
            <a href="/posts/f78d4d0c.html">IC上出色的基础设施（持续更新）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 mrxccc<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>