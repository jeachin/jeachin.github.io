<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Spring-AOP源码解析（案例+解析） | 小C的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.AOP解释摘自百度百科  AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-AOP源码解析（案例+解析）">
<meta property="og:url" content="https://mrxccc.github.io/posts/f2f19416.html">
<meta property="og:site_name" content="小C的博客">
<meta property="og:description" content="1.AOP解释摘自百度百科  AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWNiMGY3NTJlYzcwNQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY4ZWMyMzlhZTBmMA">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY5MGMwYWMwYWFlNA">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY5M2VjMzJiNGM1ZA">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY5YzhhNjRlZTBlMQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTZhNGQxYWYwOTU2MA">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTZiMTJiMTRlNDY2ZQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWNhZThhNjk3MTYxZA">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWNiY2I3MDk3YzJkZg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWQxNzk3ZDhkNzJlOQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmFjZjJmYTNmNzkwYw">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzUvMTZjNWQ5MDIxMTE2MTZlOA">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmIwNDQzNmM4NDdjNw">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjMDBjNGIzMzQzMg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjNDQ5YjE1YjFiMg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjNTMyNDEzNjhlMA">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjNmEzZDk5YjE5Zg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjN2I5OGRkYTVmNg">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjYWYzODA1YWM5Ng">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJlMDhhNGY0ZDg0Mw">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJlMzkzOWFlNTIzYw">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzgvMTZjNmYxMTcyM2RiMTIwZQ">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzgvMTZjNmYwMjEyZjlmYjg3NA">
<meta property="article:published_time" content="2019-08-09T01:23:20.000Z">
<meta property="article:modified_time" content="2024-12-04T09:00:22.669Z">
<meta property="article:author" content="mrxccc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWNiMGY3NTJlYzcwNQ">
  
    <link rel="alternate" href="/atom.xml" title="小C的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小C的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mrxccc.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Spring-AOP源码解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/f2f19416.html" class="article-date">
  <time class="dt-published" datetime="2019-08-09T01:23:20.000Z" itemprop="datePublished">2019-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Spring-AOP源码解析（案例+解析）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-AOP解释"><a href="#1-AOP解释" class="headerlink" title="1.AOP解释"></a>1.AOP解释</h1><p>摘自百度百科</p>
<blockquote>
<p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
</blockquote>
<h1 id="2-如何使用SpringAOP"><a href="#2-如何使用SpringAOP" class="headerlink" title="2.如何使用SpringAOP"></a>2.如何使用SpringAOP</h1><p>准备工作</p>
<blockquote>
<p> 1、导入aop模块；Spring AOP：(spring-aspects)<br>    2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）<br>    3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行； 		<br>    通知方法：<br>        前置通知(@Before)：logStart：在目标方法(div)运行之前运行<br>         后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）<br>         返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行<br>         异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行<br>         环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）<br>    4、给切面类的目标方法标注何时何地运行（通知注解）；<br>    5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;<br>    6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)<br>    7、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】  </p>
</blockquote>
<p><strong>切面类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class LogAspects &#123;</span><br><span class="line"></span><br><span class="line">    //抽取公共的切入点表达式</span><br><span class="line">    //1、本类引用</span><br><span class="line">    //2、其他的切面引用</span><br><span class="line">    @Pointcut(&quot;execution(public int com.bernard.aop.MathCalculator.*(..))&quot;)</span><br><span class="line">    public void pointCut()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入）</span><br><span class="line">    @Before(&quot;pointCut()&quot;)</span><br><span class="line">    public void logStart(JoinPoint joinPoint)&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;运行。。。@Before:参数列表是：&#123;&quot;+ Arrays.asList(args)+&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;com.bernard.aop.LogAspects.pointCut()&quot;)</span><br><span class="line">    public void logEnd(JoinPoint joinPoint)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;结束。。。@After&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //JoinPoint一定要出现在参数表的第一位</span><br><span class="line">    @AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;)</span><br><span class="line">    public void logReturn(JoinPoint joinPoint,Object result)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;正常返回。。。@AfterReturning:运行结果：&#123;&quot;+result+&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;exception&quot;)</span><br><span class="line">    public void logException(JoinPoint joinPoint,Exception exception)&#123;</span><br><span class="line">        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;异常。。。异常信息：&#123;&quot;+exception+&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;pointCut()&quot;)</span><br><span class="line">    public Object logAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;Around: 执行目标方法之前&quot;);</span><br><span class="line">        Object proceed = proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(&quot;Around: 执行目标方法之后&quot;);</span><br><span class="line">        return proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>配置类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">@Configuration</span><br><span class="line">public class MainConfigOfAOP &#123;</span><br><span class="line"></span><br><span class="line">    //业务逻辑类加入容器中</span><br><span class="line">    @Bean</span><br><span class="line">    public MathCalculator calculator()&#123;</span><br><span class="line">        return new MathCalculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //切面类加入到容器中</span><br><span class="line">    @Bean</span><br><span class="line">    public LogAspects logAspects()&#123;</span><br><span class="line">        return new LogAspects();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>业务逻辑类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MathCalculator &#123;</span><br><span class="line"></span><br><span class="line">    public int div(int i,int j)&#123;</span><br><span class="line">        System.out.println(&quot;MathCalculator...div...&quot;);</span><br><span class="line">        return i/j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> public class IOCTest_AOP &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test01()&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);</span><br><span class="line"></span><br><span class="line">        //1、不要自己创建对象</span><br><span class="line">//		MathCalculator mathCalculator = new MathCalculator();</span><br><span class="line">//		mathCalculator.div(1, 1);</span><br><span class="line">        MathCalculator mathCalculator = applicationContext.getBean(MathCalculator.class);</span><br><span class="line"></span><br><span class="line">        mathCalculator.div(1, 1);</span><br><span class="line"></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWNiMGY3NTJlYzcwNQ"></p>
<h1 id="3-EnableAspectJAutoProxy到底干了啥？"><a href="#3-EnableAspectJAutoProxy到底干了啥？" class="headerlink" title="3.@EnableAspectJAutoProxy到底干了啥？"></a>3.@EnableAspectJAutoProxy到底干了啥？</h1><p>开启SrpingAOP功能时，有使用一个注解为@EnableAspectJAutoProxy，查看该注解时，可以看到这个注解Import了一个类<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY4ZWMyMzlhZTBmMA"><br>跟进这个类，可以看到他是继承了ImportBeanDefinitionRegistrar，并且实现了ImportBeanDefinitionRegistrar的registerBeanDefinitions()方法，为了是导入自定义组件</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY5MGMwYWMwYWFlNA"></p>
<p>再跟进这个方法<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY5M2VjMzJiNGM1ZA"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTY5YzhhNjRlZTBlMQ"><br>整个@EnableAspectJAutoProxy注解作用就是为了<strong>注册一个id为<code>org.springframework.aop.config.internalAutoProxyCreator</code>，class为<code>AnnotationAwareAspectJAutoProxyCreator.class</code>的BeanDefinition</strong></p>
<p>AnnotationAwareAspectJAutoProxyCreatord结构<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTZhNGQxYWYwOTU2MA"></p>
<p>在它的所有父类接口中，有一个抽象类AbstractAutoProxyCreator  </p>
<blockquote>
<p>继承了：ProxyProcessorSupport类<br>实现了：SmartInstantiationAwareBeanPostProcessor和BeanFactoryAware接口</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzMvMTZjNTZiMTJiMTRlNDY2ZQ"></p>
<p><strong>具体类图如下：</strong><br>主要为了说明类之间的继承关系，方法的返回值和参数未在图中列出<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWNhZThhNjk3MTYxZA"></p>
<p>这里，我们要重点关注两个实现  </p>
<ul>
<li>SmartInstantiationAwareBeanPostProcessor:后置处理器（在我们bean初始化完成前后要做的事情）<br>postProcessBeforeInstantiation()和postProcessAfterInstantiation()两个方法做了什么事？</li>
<li>AbstractAdvisorAutoProxyCreator重写的setBeanFactory()做了什么事？</li>
<li>AnnotationAwareAspectJAutoProxyCreator的initBeanFactory做了什么事？</li>
</ul>
<p><strong>重点：AnnotationAwareAspectJAutoProxyCreator这个类是贯穿SpringAOP整个功能的类</strong><br><strong>重点：AnnotationAwareAspectJAutoProxyCreator这个类是贯穿SpringAOP整个功能的类</strong><br><strong>重点：AnnotationAwareAspectJAutoProxyCreator这个类是贯穿SpringAOP整个功能的类</strong>  </p>
<h1 id="4-Spring的refresh"><a href="#4-Spring的refresh" class="headerlink" title="4 Spring的refresh()"></a>4 Spring的refresh()</h1><p>我们进入AnnotationConfigApplicationContext的构造方法，this()和register(annotatedClasses)主要初始化spring的基础组件和<br>注册一个或多个要处理的带注释的类，AOP功能主要在refresh()方法<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWNiY2I3MDk3YzJkZg"></p>
<p>进入refresh()，里面的逻辑有很多，但Spring-AOP的实现主要看两个方法</p>
<blockquote>
<p>registerBeanPostProcessors(beanFactory);  &#x2F;&#x2F; 注册BeanPostProcessor（Bean的后置处理器）<br>finishBeanFactoryInitialization(beanFactory); &#x2F;&#x2F; 初始化所有剩下的单实例bean；  </p>
</blockquote>
<p>因为AnnotationAwareAspectJAutoProxyCreator也是一个BeanPostProcessor，所以AnnotationAwareAspectJAutoProxyCreator的注册就是在registerBeanPostProcessors(beanFactory)方法中实现的，在这一节中，会分很多小节，对registerBeanPostProcessors和finishBeanFactoryInitialization两个方法中的细节进行介绍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">        synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">            //1 刷新前的预处理</span><br><span class="line">            prepareRefresh();</span><br><span class="line">            //2 获取BeanFactory；刚创建的默认DefaultListableBeanFactory</span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">            //3 BeanFactory的预准备工作（BeanFactory进行一些设置）</span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 4 BeanFactory准备工作完成后进行的后置处理工作；</span><br><span class="line">                 // 4.1）、抽象的方法，当前未做处理。子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置</span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line">        /**************************以上是BeanFactory的创建及预准备工作  ****************/</span><br><span class="line">             </span><br><span class="line">                // 5 执行BeanFactoryPostProcessor的方法；</span><br><span class="line">                //BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的；</span><br><span class="line">                //它的重要两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor</span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">                //6 注册BeanPostProcessor（Bean的后置处理器）</span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line">                // 7 initMessageSource();初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；</span><br><span class="line">                initMessageSource();</span><br><span class="line">                // 8 初始化事件派发器</span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line">                // 9 子类重写这个方法，在容器刷新的时候可以自定义逻辑；</span><br><span class="line">                onRefresh();</span><br><span class="line">                // 10 给容器中将所有项目里面的ApplicationListener注册进来</span><br><span class="line">                registerListeners();</span><br><span class="line">                // 11.初始化所有剩下的单实例bean；</span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                // 12.完成BeanFactory的初始化创建工作；IOC容器就创建完成；</span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (BeansException ex) &#123;</span><br><span class="line">                if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                            &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">                &#125;</span><br><span class="line">                // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">                destroyBeans();</span><br><span class="line">                // Reset &#x27;active&#x27; flag.</span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line">                // Propagate exception to caller.</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                // Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">                // might not ever need metadata for singleton beans anymore...</span><br><span class="line">                resetCommonCaches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-registerBeanPostProcessors方法"><a href="#4-1-registerBeanPostProcessors方法" class="headerlink" title="4.1 registerBeanPostProcessors方法"></a>4.1 registerBeanPostProcessors方法</h2><p>registerBeanPostProcessors()的主要作用是注册bean的后置处理器来方便拦截bean的创建<br>下面的源码中，我对一些关键点都做了注释，也会对一些关键方法单独做一个小节来介绍</p>
<ul>
<li>1）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzQvMTZjNWQxNzk3ZDhkNzJlOQ"></li>
</ul>
<blockquote>
<p>基于章节2的测试，从截图看出，ioc容器有四个BeanPostProcessor<br>AutowiredAnnotationBeanPostProcessor(处理被@Autowired注解修饰的bean并注入)<br>RequiredAnnotationBeanPostProcessor(处理被@Required注解修饰的方法)<br>CommonAnnotationBeanPostProcessor(处理@PreDestroy、@PostConstruct、@Resource等多个注解的作用)等<br>AnnotationAwareAspectJAutoProxyCreator(处理@EnableAspectJAutoProxy注解，也就是AOP)  </p>
</blockquote>
<ul>
<li><pre><code>2）、给容器中加别的BeanPostProcessor
</code></pre>
</li>
<li><pre><code>3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor
</code></pre>
</li>
<li><pre><code>4）、再给容器中注册实现了Ordered接口的BeanPostProcessor  
</code></pre>
</li>
<li><pre><code>5）、注册没实现优先级接口的BeanPostProcessor  
</code></pre>
</li>
<li><pre><code>6）、把BeanPostProcessor注册到BeanFactory中；
</code></pre>
</li>
</ul>
<p>在3、4、5步骤中，注册BeanPostProcessor的时候都会调用beanFactory.getBean(ppName, BeanPostProcessor.class)方法，beanFactory.getBean方法会着重介绍，bean的获取和创建都是基于这个方法<br>AnnotationAwareAspectJAutoProxyCreator就是在第4步创建的，因为它的父类ProxyProcessorSupport实现了Ordered接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line"></span><br><span class="line">        // 1.先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor</span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Register BeanPostProcessorChecker that logs an info message when</span><br><span class="line">		// a bean is created during BeanPostProcessor instantiation, i.e. when</span><br><span class="line">		// a bean is not eligible for getting processed by all BeanPostProcessors.</span><br><span class="line">		// 2.给容器中加其他的BeanPostProcessor</span><br><span class="line">		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">		</span><br><span class="line">		// 3.优先注册实现了PriorityOrdered接口的BeanPostProcessor；</span><br><span class="line">		// Separate between BeanPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">			    </span><br><span class="line">			    // 3.1在beanFactory中获取BeanPostProcessor</span><br><span class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// First, register the BeanPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">		</span><br><span class="line">		// 4.优先注册实现了PriorityOrdered接口的BeanPostProcessor</span><br><span class="line">		// Next, register the BeanPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">		</span><br><span class="line">		// 5.注册没实现优先级接口的BeanPostProcessor</span><br><span class="line">		// Now, register all regular BeanPostProcessors.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">        // 6）、把BeanPostProcessor注册到BeanFactory中；</span><br><span class="line">		// Finally, re-register all internal BeanPostProcessors.</span><br><span class="line">		sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Re-register post-processor for detecting inner beans as ApplicationListeners,</span><br><span class="line">		// moving it to the end of the processor chain (for picking up proxies etc).</span><br><span class="line">		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>大致脑图如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmFjZjJmYTNmNzkwYw"></p>
<h2 id="4-2-getBean"><a href="#4-2-getBean" class="headerlink" title="4.2 getBean"></a>4.2 getBean</h2><p>AnnotationAwareAspectJAutoProxyCreator是一个BeanPostProcessor<br>注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中；<br>这里以AnnotationAwareAspectJAutoProxyCreator为例：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzUvMTZjNWQ5MDIxMTE2MTZlOA"><br>从beanFactory.getBean()方法获取bean实例的步骤大致如下：</p>
<ul>
<li>1）、创建Bean的实例:AbstractBeanFactory.getBean()-&gt;doGetBean()<ul>
<li>1)、将创建的Bean添加到缓存中singletonObjects(),如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）</li>
<li>2)、缓存中获取不到，开始Bean的创建对象流程</li>
<li>3)、标记当前bean已经被创建</li>
<li>4)、获取Bean的定义信息</li>
<li>5)、获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来 </li>
<li>6)、启动单实例的bean的创建流程</li>
<li>7)、创建Bean ,见4.3<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,</span><br><span class="line">			@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		final String beanName = transformedBeanName(name);</span><br><span class="line">		Object bean;</span><br><span class="line">        </span><br><span class="line">        // 1)、将创建的Bean添加到缓存中singletonObjects(),如果没有获取到创建bean </span><br><span class="line">		// Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">					logger.debug(&quot;Returning eagerly cached instance of singleton bean &#x27;&quot; + beanName +</span><br><span class="line">							&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					logger.debug(&quot;Returning cached instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">		&#125;</span><br><span class="line">        // 2)、缓存中获取不到，开始Bean的创建对象流程</span><br><span class="line">		else &#123;</span><br><span class="line">			// Fail if we&#x27;re already creating this bean instance:</span><br><span class="line">			// We&#x27;re assumably within a circular reference.</span><br><span class="line">			if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			//  获取父beanFatory 检查这个bean是否创建了</span><br><span class="line">			// Check if bean definition exists in this factory.</span><br><span class="line">			BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">			if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				// Not found -&gt; check parent.</span><br><span class="line">				String nameToLookup = originalBeanName(name);</span><br><span class="line">				if (parentBeanFactory instanceof AbstractBeanFactory) &#123;</span><br><span class="line">					return ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">							nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">				&#125;</span><br><span class="line">				else if (args != null) &#123;</span><br><span class="line">					// Delegation to parent with explicit args.</span><br><span class="line">					return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					// No args -&gt; delegate to standard getBean method.</span><br><span class="line">					return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 3)、标记当前bean已经被创建</span><br><span class="line">			if (!typeCheckOnly) &#123;</span><br><span class="line">				markBeanAsCreated(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">			    //  4)、获取Bean的定义信息</span><br><span class="line">				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">				checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">				</span><br><span class="line">				// 5)、获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来 </span><br><span class="line">				// Guarantee initialization of beans that the current bean depends on.</span><br><span class="line">				String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">				if (dependsOn != null) &#123;</span><br><span class="line">					for (String dep : dependsOn) &#123;</span><br><span class="line">						if (isDependent(beanName, dep)) &#123;</span><br><span class="line">							throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">									&quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dep + &quot;&#x27;&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">						registerDependentBean(dep, beanName);</span><br><span class="line">						try &#123;</span><br><span class="line">							getBean(dep);</span><br><span class="line">						&#125;</span><br><span class="line">						catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">							throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">									&quot;&#x27;&quot; + beanName + &quot;&#x27; depends on missing bean &#x27;&quot; + dep + &quot;&#x27;&quot;, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 6)、启动单实例的bean的创建流程</span><br><span class="line">				if (mbd.isSingleton()) &#123;</span><br><span class="line">				    // //获取到单实例bean后，添加到缓存中 singletonObjects（）</span><br><span class="line">					sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">						try &#123;</span><br><span class="line">						    // 7)、创建单实例Bean ,见4.2.1</span><br><span class="line">							return createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						catch (BeansException ex) &#123;</span><br><span class="line">							// Explicitly remove instance from singleton cache: It might have been put there</span><br><span class="line">							// eagerly by the creation process, to allow for circular reference resolution.</span><br><span class="line">							// Also remove any beans that received a temporary reference to the bean.</span><br><span class="line">							destroySingleton(beanName);</span><br><span class="line">							throw ex;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				else if (mbd.isPrototype()) &#123;</span><br><span class="line">					// It&#x27;s a prototype -&gt; create a new instance.</span><br><span class="line">					Object prototypeInstance = null;</span><br><span class="line">					try &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					finally &#123;</span><br><span class="line">						afterPrototypeCreation(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				else &#123;</span><br><span class="line">					String scopeName = mbd.getScope();</span><br><span class="line">					final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">					if (scope == null) &#123;</span><br><span class="line">						throw new IllegalStateException(&quot;No Scope registered for scope name &#x27;&quot; + scopeName + &quot;&#x27;&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					try &#123;</span><br><span class="line">						Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">							beforePrototypeCreation(beanName);</span><br><span class="line">							try &#123;</span><br><span class="line">								return createBean(beanName, mbd, args);</span><br><span class="line">							&#125;</span><br><span class="line">							finally &#123;</span><br><span class="line">								afterPrototypeCreation(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">					&#125;</span><br><span class="line">					catch (IllegalStateException ex) &#123;</span><br><span class="line">						throw new BeanCreationException(beanName,</span><br><span class="line">								&quot;Scope &#x27;&quot; + scopeName + &quot;&#x27; is not active for the current thread; consider &quot; +</span><br><span class="line">								&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">								ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Check if required type matches the type of the actual bean instance.</span><br><span class="line">		if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">				if (convertedBean == null) &#123;</span><br><span class="line">					throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">				&#125;</span><br><span class="line">				return convertedBean;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (TypeMismatchException ex) &#123;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;Failed to convert bean &#x27;&quot; + name + &quot;&#x27; to required type &#x27;&quot; +</span><br><span class="line">							ClassUtils.getQualifiedName(requiredType) + &quot;&#x27;&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return (T) bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><pre><code>2）、populateBean；给bean的各种属性赋值
</code></pre>
</li>
<li><pre><code>3）、initializeBean：初始化bean；
</code></pre>
<ul>
<li><pre><code>1）、invokeAwareMethods()：处理Aware接口的方法回调
</code></pre>
</li>
<li>2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）</li>
<li>3）、invokeInitMethods()；执行自定义的初始化方法</li>
<li>4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）；</li>
</ul>
</li>
<li>4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；–&gt;aspectJAdvisorsBuilder</li>
</ul>
<h3 id="4-2-1-createBean"><a href="#4-2-1-createBean" class="headerlink" title="4.2.1 createBean"></a>4.2.1 createBean</h3><p>AbstractAutowireCapableBeanFactory.createBean() 这个类中，有以下几个步骤：</p>
<ul>
<li>1)、解析bean的类型</li>
<li>2、让BeanPostProcessor先拦截返回代理对象–&gt;调用resolveBeforeInstantiation方法</li>
<li>3)、没有对象,创建一个bean，调用doCreateBean方法</li>
<li>4)、返回创建的bean <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">			throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">		</span><br><span class="line">		 // 1)、解析bean的类型</span><br><span class="line">		// Make sure bean class is actually resolved at this point, and</span><br><span class="line">		// clone the bean definition in case of a dynamically resolved Class</span><br><span class="line">		// which cannot be stored in the shared merged bean definition.</span><br><span class="line">		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class="line">			mbdToUse = new RootBeanDefinition(mbd);</span><br><span class="line">			mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Prepare method overrides.</span><br><span class="line">		try &#123;</span><br><span class="line">			mbdToUse.prepareMethodOverrides();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">					beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		    // 2、让BeanPostProcessor先拦截返回代理对象</span><br><span class="line">			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br><span class="line">			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">			if (bean != null) &#123;</span><br><span class="line">				return bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">					&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		    //  3)、没有对象  创建一个bean</span><br><span class="line">			Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			// 4)、返回创建的bean </span><br><span class="line">			return beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">			// A previously detected exception with proper bean creation context already,</span><br><span class="line">			// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-2-resolveBeforeInstantiation返回代理对象"><a href="#4-2-2-resolveBeforeInstantiation返回代理对象" class="headerlink" title="4.2.2 resolveBeforeInstantiation返回代理对象"></a>4.2.2 resolveBeforeInstantiation返回代理对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         // 2、让BeanPostProcessor先拦截返回代理对象</span><br><span class="line">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">if (bean != null) &#123;</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>resolveBeforeInstantiation方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">	protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">		Object bean = null;</span><br><span class="line">		if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">			// Make sure bean class is actually resolved at this point.</span><br><span class="line">			if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">				Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">				if (targetType != null) &#123;</span><br><span class="line">					bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">					if (bean != null) &#123;</span><br><span class="line">						bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.beforeInstantiationResolved = (bean != null);</span><br><span class="line">		&#125;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>applyBeanPostProcessorsBeforeInstantiation方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">	protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123;</span><br><span class="line">		for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">				if (result != null) &#123;</span><br><span class="line">					return result;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>这里源码的注释是“让beanpostprocessor有机会返回代理而不是目标bean实例”，如果成功返回代理对象，则直接返回，否则再执行doCreateBean来创建实例。从开始进入到applyBeanPostProcessorsBeforeInstantiation这个方法中，会但是对于AbstractAutoProxyCreator这个类来说，在执行applyBeanPostProcessorsBeforeInstantiation方法时，它并没有创建，所以并不会执行AbstractAutoProxyCreator的applyBeanPostProcessorsBeforeInstantiation方法和applyBeanPostProcessorsAfterInitialization，返回null,在后面的逻辑中，如果resolveBeforeInstantiation返回null,会执行doCreateBean方法，创建AbstractAutoProxyCreator</p>
<h3 id="4-2-3-doCreateBean创建实例"><a href="#4-2-3-doCreateBean创建实例" class="headerlink" title="4.2.3 doCreateBean创建实例"></a>4.2.3 doCreateBean创建实例</h3><p>当resolveBeforeInstantiation返回null时，执行doCreateBean<br>doCreateBean主要流程是：</p>
<ul>
<li>1）、创建Bean的实例</li>
<li><pre><code>2）、populateBean；给bean的各种属性赋值
</code></pre>
</li>
<li><pre><code>3）、initializeBean：初始化bean；
</code></pre>
</li>
</ul>
<p>它的主要步骤在于initializeBean方法上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</span><br><span class="line">			throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		// Instantiate the bean.</span><br><span class="line">		BeanWrapper instanceWrapper = null;</span><br><span class="line">		if (mbd.isSingleton()) &#123;</span><br><span class="line">		</span><br><span class="line">		     // 1）、【创建Bean实例】利用工厂方法或者对象的构造器创建出Bean实例；</span><br><span class="line">			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		if (instanceWrapper == null) &#123;</span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		final Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">		if (beanType != NullBean.class) &#123;</span><br><span class="line">			mbd.resolvedTargetType = beanType;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Allow post-processors to modify the merged bean definition.</span><br><span class="line">		synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">			if (!mbd.postProcessed) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">				    //调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType,</span><br><span class="line">				    beanName);</span><br><span class="line">				    //判断是否为：MergedBeanDefinitionPostProcessor 类型的，如果是，调用方法</span><br><span class="line">				    //MergedBeanDefinitionPostProcessor 后置处理器是在bean实例换之后调用的</span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Throwable ex) &#123;</span><br><span class="line">					throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">							&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.postProcessed = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">         // 判断bean 是否为单实例的，如果是单实例的添加到缓存中</span><br><span class="line">		// Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">		// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">						&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			 //添加bean到缓存中</span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Initialize the bean instance.</span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		try &#123;</span><br><span class="line">		    // 2)、给bean的各种属性赋值</span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			</span><br><span class="line">			// 3)、初始化bean</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">				throw (BeanCreationException) ex;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				throw new BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">			if (earlySingletonReference != null) &#123;</span><br><span class="line">				if (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">					for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								&quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +</span><br><span class="line">								&quot;wrapped. This means that said other beans do not use the final version of the &quot; +</span><br><span class="line">								&quot;bean. This is often the result of over-eager type matching - consider using &quot; +</span><br><span class="line">								&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Register bean as disposable.</span><br><span class="line">		try &#123;</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-initializeBean初始化bean"><a href="#4-3-2-initializeBean初始化bean" class="headerlink" title="4.3.2 initializeBean初始化bean"></a>4.3.2 initializeBean初始化bean</h3><ul>
<li>1）、invokeAwareMethods()：处理Aware接口的方法回调  </li>
<li>2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）  </li>
<li><pre><code>3）、invokeInitMethods()；执行自定义的初始化方法    
</code></pre>
</li>
<li><pre><code>4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）    
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">				invokeAwareMethods(beanName, bean);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">		// 1)、处理Aware接口的方法回调  </span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">		    // 2）、应用后置处理器的postProcessBeforeInitialization（）</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		    // 3）、执行自定义的初始化方法</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					(mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">		    // 4）、执行后置处理器的postProcessAfterInitialization（） </span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-finishBeanFactoryInitialization"><a href="#5-finishBeanFactoryInitialization" class="headerlink" title="5 finishBeanFactoryInitialization"></a>5 finishBeanFactoryInitialization</h1><p>第四章节主要是介绍创建和注册AnnotationAwareAspectJAutoProxyCreator后置处理器的过程<br>而finishBeanFactoryInitialization(beanFactory)是完成BeanFactory初始化工作、创建剩余的非懒加载单实例bean，也就是我们的业务bean：MathCalculator的创建过程是在这一步完成的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Finish the initialization of this context&#x27;s bean factory,</span><br><span class="line">	 * initializing all remaining singleton beans.</span><br><span class="line">	 */</span><br><span class="line">	protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">	     // 类型装换器</span><br><span class="line">		// Initialize conversion service for this context.</span><br><span class="line">		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">			beanFactory.setConversionService(</span><br><span class="line">					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Register a default embedded value resolver if no bean post-processor</span><br><span class="line">		// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">		// at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">		if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">			beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span><br><span class="line">		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">		for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">			getBean(weaverAwareName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Stop using the temporary ClassLoader for type matching.</span><br><span class="line">		beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">		// Allow for caching all bean definition metadata, not expecting further changes.</span><br><span class="line">		beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">		// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>beanFactory.preInstantiateSingletons()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">		if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">			this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">		List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">		// Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				if (isFactoryBean(beanName)) &#123;</span><br><span class="line">					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					if (bean instanceof FactoryBean) &#123;</span><br><span class="line">						final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">						boolean isEagerInit;</span><br><span class="line">						if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">							isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">											((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">									getAccessControlContext());</span><br><span class="line">						&#125;</span><br><span class="line">						else &#123;</span><br><span class="line">							isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">									((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">						&#125;</span><br><span class="line">						if (isEagerInit) &#123;</span><br><span class="line">							getBean(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">				    // 调用父类AbstractBeanFactory的doGetBean方法</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Trigger post-initialization callback for all applicable beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			Object singletonInstance = getSingleton(beanName);</span><br><span class="line">			if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">				final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">				if (System.getSecurityManager() != null) &#123;</span><br><span class="line">					AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">						smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">						return null;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法里面关注最后一个方法，beanFactory.preInstantiateSingletons()的作用就是创建剩余的非懒加载单实例bean，如下图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmIwNDQzNmM4NDdjNw"><br>我们的业务calculator，LogAspects就是在这里创建的，会调用父类的AbstractBeanFactory的doGetBean方法，执行流程和章节4.2的getBean方法是一个流程</p>
<p>但是创建calculator，LogAspects和创建AnnotationAwareAspectJAutoProxyCreator是有点不同的，在4.2.2章节，我们有提到，创建bean时，resolveBeforeInstantiation(beanName, mbdToUse)方法会尝试返回它的代理对象返回，否则执行doCreateBean创建bean对象，因为AnnotationAwareAspectJAutoProxyCreator已经在第4章节的registerBeanPostProcessors方法中所创建，所以在每一个bean创建之前，都会调用AnnotationAwareAspectJAutoProxyCreator的postProcessBeforeInstantiation()方法和postProcessAfterInitialization方法</p>
<h2 id="5-1-postProcessBeforeInstantiation"><a href="#5-1-postProcessBeforeInstantiation" class="headerlink" title="5.1 postProcessBeforeInstantiation()"></a>5.1 postProcessBeforeInstantiation()</h2><p><strong>AnnotationAwareAspectJAutoProxyCreator的父类AbstractAutoProxyCreator的postProcessBeforeInstantiation方法如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">		if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		    // 1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）</span><br><span class="line">			if (this.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">			// 2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean， 			或者是否是切面（@Aspect）</span><br><span class="line">			// 3）、是否需要跳过</span><br><span class="line">			if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">				this.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Create proxy here if we have a custom TargetSource.</span><br><span class="line">		// Suppresses unnecessary default instantiation of the target bean:</span><br><span class="line">		// The TargetSource will handle target instances in a custom fashion.</span><br><span class="line">		TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">		if (targetSource != null) &#123;</span><br><span class="line">			if (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">				this.targetSourcedBeans.add(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">			Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">			this.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">			return proxy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjMDBjNGIzMzQzMg"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjNDQ5YjE1YjFiMg"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjNTMyNDEzNjhlMA"><br>这个方法以MathCalculator和LogAspect的创建为例子：</p>
<ul>
<li>1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean），第一次创建肯定是没有的</li>
<li><pre><code>2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean， 			或者是否是切面（@Aspect）
</code></pre>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjNmEzZDk5YjE5Zg"></li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjN2I5OGRkYTVmNg"></p>
<ul>
<li><pre><code>3）、是否需要跳过
</code></pre>
<ul>
<li><pre><code>1）、获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】
       每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；
       判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true
</code></pre>
</li>
<li><pre><code>2）、永远返回false
</code></pre>
</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJjYWYzODA1YWM5Ng"></p>
<h2 id="5-2-postProcessAfterInitialization"><a href="#5-2-postProcessAfterInitialization" class="headerlink" title="5.2 postProcessAfterInitialization()"></a>5.2 postProcessAfterInitialization()</h2><p>AnnotationAwareAspectJAutoProxyCreator的父类AbstractAutoProxyCreator的postProcessAfterInitialization方法是在<br>章节4.3.2 initializeBean初始化bean的applyBeanPostProcessorsAfterInitialization调用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Initialize the given bean instance, applying factory callbacks</span><br><span class="line">	 * as well as init methods and bean post processors.</span><br><span class="line">	 * &lt;p&gt;Called from &#123;@link #createBean&#125; for traditionally defined beans,</span><br><span class="line">	 * and from &#123;@link #initializeBean&#125; for existing bean instances.</span><br><span class="line">	 * @param beanName the bean name in the factory (for debugging purposes)</span><br><span class="line">	 * @param bean the new bean instance we may need to initialize</span><br><span class="line">	 * @param mbd the bean definition that the bean was created with</span><br><span class="line">	 * (can also be &#123;@code null&#125;, if given an existing bean instance)</span><br><span class="line">	 * @return the initialized bean instance (potentially wrapped)</span><br><span class="line">	 * @see BeanNameAware</span><br><span class="line">	 * @see BeanClassLoaderAware</span><br><span class="line">	 * @see BeanFactoryAware</span><br><span class="line">	 * @see #applyBeanPostProcessorsBeforeInitialization</span><br><span class="line">	 * @see #invokeInitMethods</span><br><span class="line">	 * @see #applyBeanPostProcessorsAfterInitialization</span><br><span class="line">	 */</span><br><span class="line">	protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">				invokeAwareMethods(beanName, bean);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">		// 注意：这里执行的postProcessBeforeInstantiation并不是5.1章节所执行的bean,他直接返回了传过去的wrappedBean</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					(mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>postProcessAfterInitialization()代码如下：</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJlMDhhNGY0ZDg0Mw"></p>
<p>可以看出，返回了一个wrapIfNecessary(bean, beanName, cacheKey);&#x2F;&#x2F;如果需要包装<br><strong>wrapIfNecessary(bean, beanName, cacheKey);代码如下</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzcvMTZjNmJlMzkzOWFlNTIzYw"></p>
<p>前面的三个if在5.1已经有过介绍，主要看<code>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null)</code>，获取当前bean的所有增强器（通知方法），这里的当前bean也就是MathCalculator，这个方法做了如下几个步骤</p>
<ul>
<li><pre><code>1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）
</code></pre>
</li>
<li><pre><code>2、获取到能在bean使用的增强器。
</code></pre>
</li>
<li><pre><code>3、给增强器排序
</code></pre>
</li>
<li><pre><code>4、保存当前bean在advisedBeans中；
</code></pre>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzgvMTZjNmYxMTcyM2RiMTIwZQ"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzgvMTZjNmYwMjEyZjlmYjg3NA"></li>
</ul>
<p>如果当前bean需要增强，会创建当前bean的代理对象：<code>Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</code><br>protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,<br>            @Nullable Object[] specificInterceptors, TargetSource targetSource) {</p>
<pre><code>    if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;
        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
    &#125;

    ProxyFactory proxyFactory = new ProxyFactory();
    proxyFactory.copyFrom(this);

    if (!proxyFactory.isProxyTargetClass()) &#123;
        if (shouldProxyTargetClass(beanClass, beanName)) &#123;
            proxyFactory.setProxyTargetClass(true);
        &#125;
        else &#123;
            evaluateProxyInterfaces(beanClass, proxyFactory);
        &#125;
    &#125;
    // 1）、获取所有增强器（通知方法）
    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    2）、保存到proxyFactory
    proxyFactory.addAdvisors(advisors);
    proxyFactory.setTargetSource(targetSource);
    customizeProxyFactory(proxyFactory);

    proxyFactory.setFrozen(this.freezeProxy);
    if (advisorsPreFiltered()) &#123;
        proxyFactory.setPreFiltered(true);
    &#125;
    3）、创建代理对象：Spring自动决定
    return proxyFactory.getProxy(getProxyClassLoader());
&#125;
</code></pre>
<ul>
<li><pre><code>1）、获取所有增强器（通知方法）
</code></pre>
</li>
<li><pre><code>2）、保存到proxyFactory
</code></pre>
</li>
<li><pre><code>3）、创建代理对象：Spring自动决定
</code></pre>
</li>
</ul>
<p>更多精彩内容：<a href="https://mrxccc.github.io/">mrxccc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrxccc.github.io/posts/f2f19416.html" data-id="cm49opopd001t8ou4hvgm7q9p" data-title="Spring-AOP源码解析（案例+解析）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/posts/933755ce.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          同步容器与JUC并发容器的对比与介绍
        
      </div>
    </a>
  
  
    <a href="/posts/fcbd1efb.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">JUC-各种线程池汇总</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IC/">IC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7/">Java8新特性</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sonarquber/">Sonarquber</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/dfinity/">dfinity</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gitlab-ci/">gitlab-ci</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%8C%96%E5%88%B0%E4%BA%91%E5%8E%9F%E7%94%9F/">从服务化到云原生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A1%A8%E6%A0%BC%E5%A4%84%E7%90%86/">表格处理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IC/" rel="tag">IC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/POI/" rel="tag">POI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dfinity/" rel="tag">dfinity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/easyexcel/" rel="tag">easyexcel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E9%9D%A2/" rel="tag">知识面</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A8%E6%A0%BC%E5%A4%84%E7%90%86/" rel="tag">表格处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/IC/" style="font-size: 20px;">IC</a> <a href="/tags/POI/" style="font-size: 13.33px;">POI</a> <a href="/tags/dfinity/" style="font-size: 10px;">dfinity</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/easyexcel/" style="font-size: 10px;">easyexcel</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 13.33px;">区块链</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E9%9D%A2/" style="font-size: 10px;">知识面</a> <a href="/tags/%E8%A1%A8%E6%A0%BC%E5%A4%84%E7%90%86/" style="font-size: 13.33px;">表格处理</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 16.67px;">设计模式</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 10px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/f73eb048.html">设计模式-拦截过滤器</a>
          </li>
        
          <li>
            <a href="/posts/fc25c4a4.html">IC中的账户及相关操作</a>
          </li>
        
          <li>
            <a href="/posts/f78d4d0c.html">IC上出色的基础设施（持续更新）</a>
          </li>
        
          <li>
            <a href="/posts/9f2c049f.html">IC 入门课第二课</a>
          </li>
        
          <li>
            <a href="/posts/af3ae847.html">IC 入门课第一课</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 mrxccc<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>